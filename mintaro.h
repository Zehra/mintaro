// Small retro game framework. Public domain. See "unlicense" statement at the end of this file.
// mintaro - v0.2 - TBD
//
// David Reid - mackron@gmail.com

// ABOUT
// =====
// Mintaro is a small framework for building simple, retro style games. It is not a full featured game
// engine so if that's what you're after you'll need to look elsewhere. The main intent for this library
// is to just make it fun to build simple games without having to worry about annoying things like
// complex build systems, long build times and complex APIs with steep learning curves.
//
//
//
// USAGE
// =====
// Mintaro is a single-file library. To use it, do something like the following in one .c file.
//   #define MINTARO_IMPLEMENTATION
//   #include "mintaro.h"
//
// You can then #include this file in other parts of the program as you would with any other header file.
//
// Mintaro has built-in support for TGA images and WAV audio, but can also make use of stb_image and
// dr_pcx for additional image formats and stb_vorbis and dr_flac for Vorbis and FLAC audio respectively.
// To enable this, just #include them before the implementation of Mintaro:
//
//   #include "stb_image.h"
//   #include "dr_pcx.h"
//   #include "stb_vorbis.c
//   #include "dr_flac.h"
//
//   ...
//
//   #define MINTARO_IMPLEMENTATION
//   #include "mintaro.h"
//
// You only need to #include these for the _implementation_ of Mintaro. You can find stb_image, stb_vorbis
// and dr_flac in the "extras" folder.
//
//
// Building (Windows)
// ------------------
// Linking (MSVC): Nothing
// Linking (GCC/Clang): -lgdi32
//
// You will need dsound.h in your include paths, but linking to dsound.lib is unnecessary.
//
//
// Building (Linux)
// ----------------
// The Linux build uses ALSA for it's backend so you will need to install the relevant ALSA development
// pacakges for your preferred distro. It also uses X11 and pthreads, both of which should be easy to
// set up.
//
// Linking: -lX11 -lXext -lasound -lpthread -lm
//
//
//
// NOTES
// =====
// - This embeds mini_al for audio. See https://github.com/dr-soft/mini_al for more information.
// - Mintaro is not thread-safe.
//
// Graphics
// --------
// - The number of colors in the palette is configurable at initialization time, but has a maximum of 256
//   colors, with one color designated as transparency (there is only 1 level of transparency).
// - The color index to use for transparency is configurable in case you want to plug in an existing
//   palette.
//
// Audio
// -----
// - Audio data is _always_ converted to 16-bit signed integer PCM, so consider using this for your audio
//   assets. You will _not_ get quality improvements by using 24- or 32-bit formats, and you will _not_ be
//   saving memory by using 8-bit formats.
// - The sample rate for audio can be set at initialization time, but all sounds must use that same sample
//   rate. Mintaro does not currently do any sample rate conversion, though this is planned for the future.

#ifndef mintaro_h
#define mintaro_h

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN32
#define MO_WIN32
#include <windows.h>
#else
#define MO_X11
#define MO_POSIX
#include <sys/ipc.h>
#include <sys/shm.h>
#include <X11/Xatom.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/XKBlib.h>
#include <X11/extensions/XShm.h>
#endif

// External library support.
#ifdef STBI_INCLUDE_STB_IMAGE_H
#define MO_HAS_STB_IMAGE
#endif
#ifdef dr_pcx_h
#define MO_HAS_DR_PCX
#endif
#ifdef STB_VORBIS_INCLUDE_STB_VORBIS_H
#define MO_HAS_STB_VORBIS
#endif
#ifdef dr_flac_h
#define MO_HAS_DR_FLAC
#endif

///////////////////////////////////////////////////////////////////////////////
//
// BEGIN MINI_AL HEADER SECTTION
//
///////////////////////////////////////////////////////////////////////////////
#ifndef MO_USE_EXTERNAL_MINI_AL
#endif
///////////////////////////////////////////////////////////////////////////////
//
// END MINI_AL HEADER SECTTION
//
///////////////////////////////////////////////////////////////////////////////


#define MO_GLYPH_SIZE               9

typedef int mo_result;
#define MO_SUCCESS                   0
#define MO_ERROR                    -1  // A generic error.
#define MO_INVALID_ARGS             -2
#define MO_OUT_OF_MEMORY            -3
#define MO_FAILED_TO_INIT_PLATFORM  -4
#define MO_DOES_NOT_EXIST           -5
#define MO_INVALID_RESOURCE         -6
#define MO_UNSUPPORTED_IMAGE_FORMAT -7
#define MO_UNSUPPORTED_AUDIO_FORMAT -8
#define MO_FAILED_TO_INIT_AUDIO     -9
#define MO_BAD_PROFILE              -10

typedef unsigned int mo_event_type;
#define MO_EVENT_TYPE_KEY_DOWN      1
#define MO_EVENT_TYPE_KEY_UP        2

typedef unsigned int mo_button;
#define MO_BUTTON_LEFT              (1 << 0)
#define MO_BUTTON_UP                (1 << 1)
#define MO_BUTTON_RIGHT             (1 << 2)
#define MO_BUTTON_DOWN              (1 << 3)
#define MO_BUTTON_A                 (1 << 4)
#define MO_BUTTON_B                 (1 << 5)
#define MO_BUTTON_SELECT            (1 << 6)
#define MO_BUTTON_START             (1 << 7)
#define MO_BUTTON_COUNT             8

typedef unsigned int mo_key;
#define MO_KEY_BACKSPACE            0xff08
#define MO_KEY_ENTER                0xff0d
#define MO_KEY_SHIFT                0xff10
#define MO_KEY_ESCAPE               0xff1b
#define MO_KEY_SPACE                0xff20
#define MO_KEY_PAGE_UP              0xff55
#define MO_KEY_PAGE_DOWN            0xff56
#define MO_KEY_END                  0xff57
#define MO_KEY_HOME                 0xff50
#define MO_KEY_ARROW_LEFT           0x08fb
#define MO_KEY_ARROW_UP             0x08fc
#define MO_KEY_ARROW_RIGHT          0x08fd
#define MO_KEY_ARROW_DOWN           0x08fe
#define MO_KEY_DELETE               0xffff
#define MO_KEY_F1                   0xffbe
#define MO_KEY_F2                   0xffbf
#define MO_KEY_F3                   0xffc0
#define MO_KEY_F4                   0xffc1
#define MO_KEY_F5                   0xffc2
#define MO_KEY_F6                   0xffc3
#define MO_KEY_F7                   0xffc4
#define MO_KEY_F8                   0xffc5
#define MO_KEY_F9                   0xffc6
#define MO_KEY_F10                  0xffc7
#define MO_KEY_F11                  0xffc8
#define MO_KEY_F12                  0xffc9

#define MO_SOUND_GROUP_MASTER       0
#define MO_SOUND_GROUP_EFFECTS      1
#define MO_SOUND_GROUP_MUSIC        2
#define MO_SOUND_GROUP_VOICE        3
#define MO_SOUND_GROUP_COUNT        4

#if defined(_MSC_VER) && _MSC_VER < 1300
typedef   signed char       mo_int8;
typedef unsigned char       mo_uint8;
typedef   signed short      mo_int16;
typedef unsigned short      mo_uint16;
typedef   signed int        mo_int32;
typedef unsigned int        mo_uint32;
typedef   signed __int64    mo_int64;
typedef unsigned __int64    mo_uint64;
#else
#include <stdint.h>
typedef int8_t              mo_int8;
typedef uint8_t             mo_uint8;
typedef int16_t             mo_int16;
typedef uint16_t            mo_uint16;
typedef int32_t             mo_int32;
typedef uint32_t            mo_uint32;
typedef int64_t             mo_int64;
typedef uint64_t            mo_uint64;
#endif
typedef mo_int8             mo_bool8;
typedef mo_int32            mo_bool32;
typedef mo_uint8            mo_color_index;
#define MO_TRUE             1
#define MO_FALSE            0

typedef struct mo_context mo_context;
typedef struct mo_sound_source mo_sound_source;
typedef struct mo_sound_group mo_sound_group;
typedef struct mo_sound mo_sound;

typedef enum
{
    mo_image_format_unknown = 0,
    mo_image_format_native,
    mo_image_format_rgba8
} mo_image_format;

typedef enum
{
    mo_sound_source_type_raw,
    mo_sound_source_type_vorbis,
    mo_sound_source_type_flac
} mo_sound_source_type;

#ifdef _MSC_VER
    #pragma warning(push)
    #pragma warning(disable:4201)
#endif
typedef union
{
    struct
    {
        mo_uint8 b;
        mo_uint8 g;
        mo_uint8 r;
        mo_uint8 a;
    };

    mo_uint32 rgba;
} mo_color_rgba;
#ifdef _MSC_VER
    #pragma warning(pop)
#endif

typedef struct
{
    float y;
    float u;
    float v;
} mo_color_yuv;

typedef struct
{
    mo_uint32 resolutionX;      // The width of the virtual screen.
    mo_uint32 resolutionY;      // The height of the virtual screen.
    mo_color_index transparentColorIndex;   // The index of the color in the palette representing transparency.
    mo_uint32 paletteSize;      // The number of available colors. Maximum of 256.
    mo_color_rgba palette[256]; // Palette colors.
    mo_uint32 audioChannels;    // The number of channels to use for audio. TODO: Implement me. Requires changes to mixing.
    mo_uint32 audioSampleRate;  // The sample rate to use for audio.
} mo_profile;

typedef struct
{
    mo_uint32 width;
    mo_uint32 height;
    mo_image_format format;
    mo_uint8 pData[1];
} mo_image;

struct mo_sound_source
{
    mo_sound_source_type type;
    union
    {
        struct
        {
            mo_uint32 channels;
            mo_uint32 sampleRate;
            mo_uint64 sampleCount;
            mo_int16 pSampleData[1];
        } raw;

        struct
        {
            size_t dataSize;
            mo_uint8 pData[1];
        } vorbis;

        struct
        {
            size_t dataSize;
            mo_uint8 pData[1];
        } flac;
    };
};

struct mo_sound
{
    mo_context* pContext;
    mo_sound_source* pSource;
    mo_uint32 group;
    float linearVolume;
    float pan;
    mo_uint32 flags;
    mo_bool32 isMarkedForDeletion;

    // Streaming.
    union
    {
        struct
        {
            mo_uint64 currentSample;
        } raw;

        struct
        {
            mo_uint64 currentSample;
            /*stb_vorbis**/ void* pDecoder;
        } vorbis;

        struct
        {
            mo_uint64 currentSample;
            /*drflac**/ void* pDecoder;
        } flac;
    };
};

struct mo_sound_group
{
    float linearVolume;
    mo_uint32 flags;
};


typedef struct
{
    int64_t counter;
} mo_timer;

// Initializes a high-resolution timer.
void mo_timer_init(mo_timer* pTimer);

// Ticks the timer and returns the number of seconds since the previous tick.
//
// The maximum return value is about 140 years or so.
double mo_timer_tick(mo_timer* pTimer);


typedef void (* mo_on_step_proc)(mo_context* pContext, double dt);
typedef void (* mo_on_log_proc) (mo_context* pContext, const char* message);

struct mo_context
{
    mo_on_step_proc onStep;
    mo_on_log_proc onLog;
    void* pUserData;

    // The profile used to initialize the context. This defines things like the screen resolution
    // and the palette.
    mo_profile profile;

    // The pixel data of the virtual screen. Each pixel is reprsented with a single byte which is
    // an index into the palette.
    mo_color_index* screen;

    // Button state. A set bit means the key is down.
    unsigned int buttonState;
    unsigned int buttonPressState;
    unsigned int buttonReleaseState;

    // Key bindings.
    mo_key keymap[MO_BUTTON_COUNT];

    // Timer.
    mo_timer timer;

    // Boolean flags;
    mo_uint32 flags;


    // The platform-specific window.
#ifdef MO_WIN32
    HWND hWnd;
    HDC hDC;
    int windowWidth;
    int windowHeight;
    HDC hDIBDC;
    HBITMAP hDIBSection;
    void* pScreenRGBA_DIB;
#endif
#ifdef MO_X11
    Window windowX11;
    GC gcX11;
    XImage* pPresentBufferX11;
    XShmSegmentInfo shmInfo;    // Only used if MIT-SHM is supported.
#endif

    // The playback device for audio. This always uses the default device for now.
    mal_device playbackDevice2;

    // Sound groups. There's a fixed number of groups, and they are referenced with an index.
    mo_sound_group soundGroups[MO_SOUND_GROUP_COUNT];

    // TODO: Improve memory management for sounds.
    //
    // Sounds. This is just a basic realloc()'ed array of mo_sound* pointers.
    mo_sound** ppSounds;
    mo_uint32 soundCount;
    mo_uint32 soundBufferSize;

    // Keeps track of whether or not there is at least one sound needing to be deleted at the end
    // of the next step. This is used for garbage collection of sounds.
    mo_bool32 isSoundMarkedForDeletion;



    // Dynamically sized data.
    mo_uint8 pExtraData[1];
};

// Initializes a context. pProfile can be null, in which case it defaults to 160x144, with a 255 color general palette.
mo_result mo_init(mo_profile* pProfile, mo_uint32 windowSizeX, mo_uint32 windowSizeY, const char* title, mo_on_step_proc onStep, void* pUserData, mo_context** ppContext);

// Uninitializes a context.
void mo_uninit(mo_context* pContext);

// Runs the game. Call mo_close() to exit the main loop.
int mo_run(mo_context* pContext);

// Exits the game's main loop. This does not uninitialize the context.
void mo_close(mo_context* pContext);

// Posts a log message.
void mo_log(mo_context* pContext, const char* message);
void mo_logf(mo_context* pContext, const char* format, ...);


//// Resources ////

// Creates an image from raw image data.
mo_result mo_image_create(mo_context* pContext, unsigned int width, unsigned int height, mo_image_format format, const void* pData, mo_image** ppImage);

// Loads an image. The image can be unloaded with mo_delete_image().
mo_result mo_image_load(mo_context* pContext, const char* filePath, mo_image** ppImage);

// Deletes an image.
void mo_image_delete(mo_context* pContext, mo_image* pImage);


//// Drawing ////

// Finds the color index for the given RGBA color code.
mo_color_index mo_find_closest_color(mo_context* pContext, mo_color_rgba color);

// Clears the screen.
void mo_clear(mo_context* pContext, mo_color_index colorIndex);

// Draws a quad.
void mo_draw_quad(mo_context* pContext, int posX, int posY, int sizeX, int sizeY, mo_color_index colorIndex);

// Draws a string of text.
void mo_draw_text(mo_context* pContext, int posX, int posY, mo_color_index colorIndex, const char* text);
void mo_draw_textf(mo_context* pContext, int posX, int posY, mo_color_index colorIndex, const char* format, ...);

// Draws an image.
void mo_draw_image(mo_context* pContext, int dstX, int dstY, mo_image* pImage, int srcX, int srcY, int srcWidth, int srcHeight);

// Draws an image with scaling.
void mo_draw_image_scaled(mo_context* pContext, int dstX, int dstY, int dstWidth, int dstHeight, mo_image* pImage, int srcX, int srcY, int srcWidth, int srcHeight/*, float rotation*/);


//// Audio ////

// Creates a sound source. When a sound is played, you pass in a reference to this source.
mo_result mo_sound_source_create(mo_context* pContext, unsigned int channels, unsigned int sampleRate, mo_uint64 sampleCount, const mo_int16* pSampleData, mo_sound_source** ppSource);
mo_result mo_sound_source_create_vorbis(mo_context* pContext, size_t dataSize, const void* pData, mo_sound_source** ppSource);
mo_result mo_sound_source_create_flac(mo_context* pContext, size_t dataSize, const void* pData, mo_sound_source** ppSource);

// Loads a sound source from a file.
mo_result mo_sound_source_load(mo_context* pContext, const char* filePath, mo_sound_source** ppSource);

// Deletes a sound source.
void mo_sound_source_delete(mo_sound_source* pSource);

// Helper function for creating a sound tied to the given sound source, play it, and then delete it once it's
// finished playing. The sound does not loop.
mo_result mo_play_sound_source(mo_context* pContext, mo_sound_source* pSource, mo_uint32 group);


// Pauses playback of all sounds in the given sound group.
void mo_sound_group_pause(mo_context* pContext, mo_uint32 group);

// Resumes playback of all sounds in the given sound group.
void mo_sound_group_resume(mo_context* pContext, mo_uint32 group);

// Determines whether or not the given group is paused.
mo_bool32 mo_sound_group_is_paused(mo_context* pContext, mo_uint32 group);

// Sets the volume of the group. This is modulated with the volumes of each individual sound.
void mo_sound_group_set_volume(mo_context* pContext, mo_uint32, float linearVolume);


// Creates a sound. The sound group can be null in which case it'll be added to the global group.
//
// The <group> parameter should be one of the following:
//   - 0 (same as MO_SOUND_GROUP_MASTER)
//   - MO_SOUND_GROUP_MASTER
//   - MO_SOUND_GROUP_EFFECTS
//   - MO_SOUND_GROUP_MUSIC
//   - MO_SOUND_GROUP_VOICE
mo_result mo_sound_create(mo_context* pContext, mo_sound_source* pSource, mo_uint32 group, mo_sound** ppSound);

// Deletes a sound.
void mo_sound_delete(mo_sound* pSound);

// Marks a sound for deletion. The sound will be deleted for real at the end of the next step.
void mo_sound_mark_for_deletion(mo_sound* pSound);

// Sets the volume of the given sound. The volume is linear.
void mo_sound_set_volume(mo_sound* pSound, float linearVolume);

// Plays the given sound.
void mo_sound_play(mo_sound* pSound, mo_bool32 loop);

// Stops playback of the given sound.
void mo_sound_stop(mo_sound* pSound);

// Determines whether or not the given sound is playing.
mo_bool32 mo_sound_is_playing(mo_sound* pSound);

// Determines whether or not the given sound is looping.
mo_bool32 mo_sound_is_looping(mo_sound* pSound);



//// Input ////

// Binds a key to a button.
void mo_bind_key_to_button(mo_context* pContext, mo_key key, mo_button button);

// Retrieves the button bound to the given key. Returns 0 if the key is not bound to any button.
mo_button mo_get_key_binding(mo_context* pContext, mo_key key);

// Determines if a button is currently down.
mo_bool32 mo_is_button_down(mo_context* pContext, unsigned int button);

// Determines if a button has just been pressed.
mo_bool32 mo_was_button_pressed(mo_context* pContext, unsigned int button);

// Determines if a button has just been released.
mo_bool32 mo_was_button_released(mo_context* pContext, unsigned int button);


//// Misc ////
#define mo_degrees(radians) ((radians) * 57.29577951308232087685f)
#define mo_radians(degrees) ((degrees) *  0.01745329251994329577f)

// Retrieves the height of a line.
mo_uint32 mo_get_line_height(mo_context* pContext);

// Retrieves the width of a character.
mo_uint32 mo_get_character_width(mo_context* pContext);

// Retrieves the width of the given string.
mo_uint32 mo_get_text_width(mo_context* pContext, const char* text);

#ifdef __cplusplus
}
#endif
#endif  //dr_gbe_h

///////////////////////////////////////////////////////////////////////////////
//
// IMPLEMENTATION
//
///////////////////////////////////////////////////////////////////////////////
#ifdef MINTARO_IMPLEMENTATION
#include <assert.h>
#include <stdio.h>  // Required for printf() and family which is used in mo_logf().
#include <stdarg.h> // va_list, va_start, va_arg, va_end

// Standard library functions.
#ifndef mo_zero_memory
#ifdef _WIN32
#define mo_zero_memory(p, sz) ZeroMemory((p), (sz))
#else
#define mo_zero_memory(p, sz) memset((p), 0, (sz))
#endif
#endif

#ifndef mo_copy_memory
#ifdef _WIN32
#define mo_copy_memory(dst, src, sz) CopyMemory((dst), (src), (sz))
#else
#define mo_copy_memory(dst, src, sz) memcpy((dst), (src), (sz))
#endif
#endif

#ifndef mo_malloc
#ifdef _WIN32
#define mo_malloc(sz) HeapAlloc(GetProcessHeap(), 0, (sz))
#else
#define mo_malloc(sz) malloc((sz))
#endif
#endif

#ifndef mo_calloc
#ifdef _WIN32
#define mo_calloc(sz) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (sz))
#else
#define mo_calloc(sz) calloc(1, (sz))
#endif
#endif

#ifndef mo_realloc
#ifdef _WIN32
// HeapReAlloc() has slightly different behaviour to realloc().
#define mo_realloc(p, sz) (((sz) > 0) ? ((p) ? HeapReAlloc(GetProcessHeap(), 0, (p), (sz)) : HeapAlloc(GetProcessHeap(), 0, (sz))) : ((VOID*)(SIZE_T)(HeapFree(GetProcessHeap(), 0, (p)) & 0)))
#else
#define mo_realloc(p, sz) realloc((p), (sz))
#endif
#endif

#ifndef mo_free
#ifdef _WIN32
#define mo_free(p) HeapFree(GetProcessHeap(), 0, (p))
#else
#define mo_free(p) free((p))
#endif
#endif

#define mo_zero_object(p) mo_zero_memory((p), sizeof(*(p)))

#ifndef mo_assert
#ifdef _WIN32
#define mo_assert(condition) assert(condition)
#else
#define mo_assert(condition) assert(condition)
#endif
#endif

#define mo_countof(x)              (sizeof(x) / sizeof(x[0]))
#define mo_max(x, y)               (((x) > (y)) ? (x) : (y))
#define mo_min(x, y)               (((x) < (y)) ? (x) : (y))
#define mo_clamp(x, lo, hi)        (mo_max(lo, mo_min(x, hi)))

#ifdef MO_X11
#include <stdlib.h>
#include <string.h> // For memset()
#include <float.h>  // <-- What's this one for?
#include <time.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif

// Atomics.
#if defined(_WIN32) && defined(_MSC_VER)
#define mo_atomic_increment(a) InterlockedIncrement((LONG*)a)
#define mo_atomic_decrement(a) InterlockedDecrement((LONG*)a)
#else
#define mo_atomic_increment(a) __sync_add_and_fetch(a, 1)
#define mo_atomic_decrement(a) __sync_sub_and_fetch(a, 1)
#endif

#define MO_FLAG_CLOSING                     (1 << 0)
#define MO_FLAG_X11_USING_SHM               (1 << 1)

#define MO_SOUND_GROUP_FLAG_PAUSED          (1 << 0)

#define MO_SOUND_FLAG_PLAYING               (1 << 0)
#define MO_SOUND_FLAG_PAUSED                (1 << 1)
#define MO_SOUND_FLAG_LOOPING               (1 << 2)
#define MO_SOUND_FLAG_STREAMING             (1 << 3)
#define MO_SOUND_FLAG_STOP_ON_NEXT_CHUNK    (1 << 4)
#define MO_SOUND_FLAG_INLINED               (1 << 5)    // Set when the sound was created by mo_play_sound_source().

static mo_uint32 g_moDefaultPalette[256] = {
    0xFF000000, 0xFF000033, 0xFF000066, 0xFF000099, 0xFF0000CC, 0xFF0000FF, 0xFF002B00, 0xFF002B33, 0xFF002B66, 0xFF002B99, 0xFF002BCC, 0xFF002BFF, 0xFF005500, 0xFF005533, 0xFF005566, 0xFF005599,
    0xFF0055CC, 0xFF0055FF, 0xFF008000, 0xFF008033, 0xFF008066, 0xFF008099, 0xFF0080CC, 0xFF0080FF, 0xFF00AA00, 0xFF00AA33, 0xFF00AA66, 0xFF00AA99, 0xFF00AACC, 0xFF00AAFF, 0xFF00D500, 0xFF00D533,
    0xFF00D566, 0xFF00D599, 0xFF00D5CC, 0xFF00D5FF, 0xFF00FF00, 0xFF00FF33, 0xFF00FF66, 0xFF00FF99, 0xFF00FFCC, 0xFF00FFFF, 0xFF330000, 0xFF330033, 0xFF330066, 0xFF330099, 0xFF3300CC, 0xFF3300FF,
    0xFF332B00, 0xFF332B33, 0xFF332B66, 0xFF332B99, 0xFF332BCC, 0xFF332BFF, 0xFF335500, 0xFF335533, 0xFF335566, 0xFF335599, 0xFF3355CC, 0xFF3355FF, 0xFF338000, 0xFF338033, 0xFF338066, 0xFF338099,
    0xFF3380CC, 0xFF3380FF, 0xFF33AA00, 0xFF33AA33, 0xFF33AA66, 0xFF33AA99, 0xFF33AACC, 0xFF33AAFF, 0xFF33D500, 0xFF33D533, 0xFF33D566, 0xFF33D599, 0xFF33D5CC, 0xFF33D5FF, 0xFF33FF00, 0xFF33FF33,
    0xFF33FF66, 0xFF33FF99, 0xFF33FFCC, 0xFF33FFFF, 0xFF660000, 0xFF660033, 0xFF660066, 0xFF660099, 0xFF6600CC, 0xFF6600FF, 0xFF662B00, 0xFF662B33, 0xFF662B66, 0xFF662B99, 0xFF662BCC, 0xFF662BFF,
    0xFF665500, 0xFF665533, 0xFF665566, 0xFF665599, 0xFF6655CC, 0xFF6655FF, 0xFF668000, 0xFF668033, 0xFF668066, 0xFF668099, 0xFF6680CC, 0xFF6680FF, 0xFF66AA00, 0xFF66AA33, 0xFF66AA66, 0xFF66AA99,
    0xFF66AACC, 0xFF66AAFF, 0xFF66D500, 0xFF66D533, 0xFF66D566, 0xFF66D599, 0xFF66D5CC, 0xFF66D5FF, 0xFF66FF00, 0xFF66FF33, 0xFF66FF66, 0xFF66FF99, 0xFF66FFCC, 0xFF66FFFF, 0xFF990000, 0xFF990033,
    0xFF990066, 0xFF990099, 0xFF9900CC, 0xFF9900FF, 0xFF992B00, 0xFF992B33, 0xFF992B66, 0xFF992B99, 0xFF992BCC, 0xFF992BFF, 0xFF995500, 0xFF995533, 0xFF995566, 0xFF995599, 0xFF9955CC, 0xFF9955FF,
    0xFF998000, 0xFF998033, 0xFF998066, 0xFF998099, 0xFF9980CC, 0xFF9980FF, 0xFF99AA00, 0xFF99AA33, 0xFF99AA66, 0xFF99AA99, 0xFF99AACC, 0xFF99AAFF, 0xFF99D500, 0xFF99D533, 0xFF99D566, 0xFF99D599,
    0xFF99D5CC, 0xFF99D5FF, 0xFF99FF00, 0xFF99FF33, 0xFF99FF66, 0xFF99FF99, 0xFF99FFCC, 0xFF99FFFF, 0xFFCC0000, 0xFFCC0033, 0xFFCC0066, 0xFFCC0099, 0xFFCC00CC, 0xFFCC00FF, 0xFFCC2B00, 0xFFCC2B33,
    0xFFCC2B66, 0xFFCC2B99, 0xFFCC2BCC, 0xFFCC2BFF, 0xFFCC5500, 0xFFCC5533, 0xFFCC5566, 0xFFCC5599, 0xFFCC55CC, 0xFFCC55FF, 0xFFCC8000, 0xFFCC8033, 0xFFCC8066, 0xFFCC8099, 0xFFCC80CC, 0xFFCC80FF,
    0xFFCCAA00, 0xFFCCAA33, 0xFFCCAA66, 0xFFCCAA99, 0xFFCCAACC, 0xFFCCAAFF, 0xFFCCD500, 0xFFCCD533, 0xFFCCD566, 0xFFCCD599, 0xFFCCD5CC, 0xFFCCD5FF, 0xFFCCFF00, 0xFFCCFF33, 0xFFCCFF66, 0xFFCCFF99,
    0xFFCCFFCC, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF0033, 0xFFFF0066, 0xFFFF0099, 0xFFFF00CC, 0xFFFF00FF, 0xFFFF2B00, 0xFFFF2B33, 0xFFFF2B66, 0xFFFF2B99, 0xFFFF2BCC, 0xFFFF2BFF, 0xFFFF5500, 0xFFFF5533,
    0xFFFF5566, 0xFFFF5599, 0xFFFF55CC, 0xFFFF55FF, 0xFFFF8000, 0xFFFF8033, 0xFFFF8066, 0xFFFF8099, 0xFFFF80CC, 0xFFFF80FF, 0xFFFFAA00, 0xFFFFAA33, 0xFFFFAA66, 0xFFFFAA99, 0xFFFFAACC, 0xFFFFAAFF,
    0xFFFFD500, 0xFFFFD533, 0xFFFFD566, 0xFFFFD599, 0xFFFFD5CC, 0xFFFFD5FF, 0xFFFFFF00, 0xFFFFFF33, 0xFFFFFF66, 0xFFFFFF99, 0xFFFFFFCC, 0xFFFFFFFF, 0xFF404040, 0xFF808080, 0xFFC0C0C0, 0x00000000
};

static inline float mo_clampf(float a, float lo, float hi)
{
    return (a > hi) ? hi : ((a < lo) ? lo : a);
}

#ifdef MO_WIN32
static LARGE_INTEGER g_moTimerFrequency = {{0}};
void mo_timer_init(mo_timer* pTimer)
{
    if (g_moTimerFrequency.QuadPart == 0) {
        QueryPerformanceFrequency(&g_moTimerFrequency);
    }

    LARGE_INTEGER counter;
    QueryPerformanceCounter(&counter);
    pTimer->counter = (uint64_t)counter.QuadPart;
}

double mo_timer_tick(mo_timer* pTimer)
{
    LARGE_INTEGER counter;
    if (!QueryPerformanceCounter(&counter)) {
        return 0;
    }

    long long newTimeCounter = counter.QuadPart;
    long long oldTimeCounter = pTimer->counter;

    pTimer->counter = newTimeCounter;

    return (newTimeCounter - oldTimeCounter) / (double)g_moTimerFrequency.QuadPart;
}
#endif

#ifdef MO_X11
void mo_timer_init(mo_timer* pTimer)
{
    struct timespec newTime;
    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &newTime);

    pTimer->counter = (newTime.tv_sec * 1000000000LL) + newTime.tv_nsec;
}

double mo_timer_tick(mo_timer* pTimer)
{
    struct timespec newTime;
    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &newTime);

    long long newTimeCounter = (newTime.tv_sec * 1000000000LL) + newTime.tv_nsec;
    long long oldTimeCounter = pTimer->counter;

    pTimer->counter = newTimeCounter;

    return (newTimeCounter - oldTimeCounter) / 1000000000.0;
}
#endif





static inline void mo__on_button_down(mo_context* pContext, unsigned int button)
{
    if (button == 0) return;
    if ((pContext->buttonState & button) == 0) {
        pContext->buttonState |= button;
        pContext->buttonPressState |= button;
        pContext->buttonReleaseState &= ~button;
    }
}

static inline void mo__on_button_up(mo_context* pContext, unsigned int button)
{
    if (button == 0) return;
    pContext->buttonState &= ~button;
    pContext->buttonPressState &= ~button;
    pContext->buttonReleaseState |= button;
}

#ifdef _WIN32
static const char* g_MintaroWndClassName = "mintaro.WindowClass";
static LONG g_MintaroInitCounter = 0;

static mo_bool32 mo_is_win32_mouse_button_key_code(WPARAM wParam)
{
    return wParam == VK_LBUTTON || wParam == VK_RBUTTON || wParam == VK_MBUTTON || wParam == VK_XBUTTON1 || wParam == VK_XBUTTON2;
}

static mo_key mo_convert_key_code__win32(WPARAM wParam)
{
    switch (wParam)
    {
        case VK_BACK:   return MO_KEY_BACKSPACE;
        case VK_RETURN: return MO_KEY_ENTER;
        case VK_SHIFT:  return MO_KEY_SHIFT;
        case VK_ESCAPE: return MO_KEY_ESCAPE;
        case VK_SPACE:  return MO_KEY_SPACE;
        case VK_PRIOR:  return MO_KEY_PAGE_UP;
        case VK_NEXT:   return MO_KEY_PAGE_DOWN;
        case VK_END:    return MO_KEY_END;
        case VK_HOME:   return MO_KEY_HOME;
        case VK_LEFT:   return MO_KEY_ARROW_LEFT;
        case VK_UP:     return MO_KEY_ARROW_UP;
        case VK_RIGHT:  return MO_KEY_ARROW_RIGHT;
        case VK_DOWN:   return MO_KEY_ARROW_DOWN;
        case VK_DELETE: return MO_KEY_DELETE;
        case VK_F1:     return MO_KEY_F1;
        case VK_F2:     return MO_KEY_F2;
        case VK_F3:     return MO_KEY_F3;
        case VK_F4:     return MO_KEY_F4;
        case VK_F5:     return MO_KEY_F5;
        case VK_F6:     return MO_KEY_F6;
        case VK_F7:     return MO_KEY_F7;
        case VK_F8:     return MO_KEY_F8;
        case VK_F9:     return MO_KEY_F9;
        case VK_F10:    return MO_KEY_F10;
        case VK_F11:    return MO_KEY_F11;
        case VK_F12:    return MO_KEY_F12;
        default: break;
    }

    return (mo_key)wParam;
}

static LRESULT DefaultWindowProcWin32(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    mo_context* pContext = (mo_context*)GetWindowLongPtrA(hWnd, 0);
    if (pContext == NULL) {
        return DefWindowProcA(hWnd, msg, wParam, lParam);
    }

    switch (msg)
    {
        case WM_CLOSE:
        {
            mo_close(pContext);
            return 0;
        }

        case WM_SIZE:
        {
            pContext->windowWidth = LOWORD(lParam);
            pContext->windowHeight = HIWORD(lParam);
        } break;

        case WM_KEYDOWN:
        {
            if (!mo_is_win32_mouse_button_key_code(wParam)) {
                if ((lParam & (1 << 30)) == 0) {    // <-- This checks for auto-repeat. We want to ignore auto-repeated key-down events.
                    mo__on_button_down(pContext, mo_get_key_binding(pContext, mo_convert_key_code__win32(wParam)));
                }
            }
        } break;

        case WM_KEYUP:
        {
            mo__on_button_up(pContext, mo_get_key_binding(pContext, mo_convert_key_code__win32(wParam)));
        } break;

        default: break;
    }

    return DefWindowProcA(hWnd, msg, wParam, lParam);
}
#else
static int g_MintaroInitCounter = 0;
static Display* g_moX11Display = NULL;
static Atom g_WM_DELETE_WINDOW = 0;
static Atom g_Atom_moWindow = 0;

static inline void mo_set_x11_window_property(Display* display, Window window, Atom property, const void* pUserData)
{
    XChangeProperty(display, window, property, XA_INTEGER, 8, PropModeReplace, (const unsigned char*)&pUserData, sizeof(pUserData));
}

static inline void* mo_get_x11_window_property(Display* display, Window window, Atom property)
{
    Atom actualType;
    int unused1;
    unsigned long unused2;
    unsigned long unused3;

    unsigned char* pRawData;
    XGetWindowProperty(display, window, property, 0, sizeof(void*), False, XA_INTEGER, &actualType, &unused1, &unused2, &unused3, &pRawData);

    void* pUserData;
    mo_copy_memory(&pUserData, pRawData, sizeof(pUserData));

    XFree(pRawData);
    return pUserData;
}

void mo_x11_create_presentation_buffer(mo_context* pContext, unsigned int sizeX, unsigned int sizeY)
{
    if (pContext == NULL || pContext->pPresentBufferX11 != NULL) return;
    if (sizeX == 0) sizeX = 1;
    if (sizeY == 0) sizeY = 1;

    unsigned int depth = 24;    // Setting this to 32 doesn't work in my testing.

    if (pContext->flags & MO_FLAG_X11_USING_SHM) {
        XImage* pImage = XShmCreateImage(g_moX11Display, CopyFromParent, depth, ZPixmap, 0,
            &pContext->shmInfo, sizeX, sizeY);
        if (pImage == NULL) {
            return; // Failed to create the image.
        }

        pContext->shmInfo.shmid = shmget(IPC_PRIVATE, pImage->bytes_per_line * pImage->height, IPC_CREAT | 0777);
        if (pContext->shmInfo.shmid < 0) {
            XDestroyImage(pImage);
            return; // Failed to allocate shared memory.
        }

        pContext->shmInfo.shmaddr = pImage->data = (char*)shmat(pContext->shmInfo.shmid, 0, 0);
        if (pContext->shmInfo.shmaddr == (char*)-1) {
            XDestroyImage(pImage);
            return;
        }

        pContext->shmInfo.readOnly = False;
        XShmAttach(g_moX11Display, &pContext->shmInfo);

        pContext->pPresentBufferX11 = pImage;
    } else {
        char* pImageData = (char*)mo_malloc(sizeX * sizeY * 4);
        if (pImageData == NULL) {
            return; // Out of memory.
        }

        pContext->pPresentBufferX11 = XCreateImage(g_moX11Display, CopyFromParent, depth, ZPixmap, 0,
            pImageData, sizeX, sizeY, 32, 0);
        if (pContext->pPresentBufferX11 == NULL) {
            return; // Failed to create the image.
        }
    }
}

void mo_x11_delete_presentation_buffer(mo_context* pContext)
{
    if (pContext == NULL || pContext->pPresentBufferX11 == NULL) return;

    if (pContext->flags & MO_FLAG_X11_USING_SHM) {
        XShmDetach(g_moX11Display, &pContext->shmInfo);
        XDestroyImage(pContext->pPresentBufferX11);
        shmdt(pContext->shmInfo.shmaddr);
    } else {
        mo_free(pContext->pPresentBufferX11->data);
        XDestroyImage(pContext->pPresentBufferX11);
    }

    pContext->pPresentBufferX11 = NULL;
}

void mo_x11_resize_presentation_buffer(mo_context* pContext, unsigned int sizeX, unsigned int sizeY)
{
    if (pContext == NULL) return;
    mo_x11_delete_presentation_buffer(pContext);
    mo_x11_create_presentation_buffer(pContext, sizeX, sizeY);
}

void mo_x11_present(mo_context* pContext)
{
    if (pContext == NULL || pContext->pPresentBufferX11 == NULL) return;

    if (pContext->flags & MO_FLAG_X11_USING_SHM) {
        XShmPutImage(g_moX11Display, pContext->windowX11, pContext->gcX11, pContext->pPresentBufferX11,
            0, 0, 0, 0, pContext->pPresentBufferX11->width, pContext->pPresentBufferX11->height, False);
    } else {
        XPutImage(g_moX11Display, pContext->windowX11, pContext->gcX11, pContext->pPresentBufferX11,
            0, 0, 0, 0, pContext->pPresentBufferX11->width, pContext->pPresentBufferX11->height);
    }
}
#endif



///////////////////////////////////////////////////////////////////////////////
//
// AUDIO
//
///////////////////////////////////////////////////////////////////////////////
void mo_on_log__mal(mal_context* pContext, mal_device* pDevice, const char* message)
{
    (void)pContext;

    if (pDevice != NULL) {
        mo_logf((mo_context*)pDevice->pUserData, "[AUDIO] %s", message);
    }
}

mo_uint32 mo_sound__read_and_accumulate_frames(mo_sound* pSound, float linearVolume, mo_uint32 frameCount, mo_int16* pFrames)
{
    // This is the main mixing function. pFrames is an in/out buffer - samples are read from the sound's data source
    // and then accumated with the samples already in the buffer.
    //
    // When a sound reaches the end of it's data source it will either loop or just stop. If it's an inline sound it
    // will be _marked_ for deletion (actual deletion will happen later at the end of the next step). The reason it
    // it only marked for deletion is because Mintaro is not thread-safe and this function will be called on another
    // thread to the main stepping thread.

    // Currently assuming the device is stereo. When/if different channel counts are supported we'll need to look
    // into making this more robust.
    mo_assert(pSound->pContext->playbackDevice2.channels <= 2);

    mo_uint32 totalFramesRead = 0;

    mo_sound_source* pSource = pSound->pSource;
    mo_assert(pSource != NULL);

    if (pSource->type == mo_sound_source_type_raw)
    {
        const mo_uint32 soundChannels = pSound->pSource->raw.channels;
        const mo_uint32 deviceChannels = pSound->pContext->playbackDevice2.channels;
        while (frameCount > 0) {
            mo_uint64 framesAvailable = (pSound->pSource->raw.sampleCount - pSound->raw.currentSample) / soundChannels;
            if (framesAvailable > frameCount) {
                framesAvailable = frameCount;
            }

            if (deviceChannels == 1) {
                // Mono. For converting to mono all we do is just average each channel.
                for (mo_uint32 iFrame = 0; iFrame < framesAvailable; ++iFrame) {
                    float totalPCM = 0;
                    for (mo_uint32 iChannel = 0; iChannel < soundChannels; ++iChannel) {
                        totalPCM += (float)pSound->pSource->raw.pSampleData[pSound->raw.currentSample + iFrame];
                    }

                    float outputSample = pFrames[iFrame] + ((totalPCM / soundChannels) * linearVolume);
                    pFrames[iFrame] = (mo_int16)(mo_clampf(outputSample, -32768.0f, 32767.0f));
                }
                pSound->raw.currentSample += framesAvailable * soundChannels;
            } else {
                // Stereo.
                if (soundChannels == 1) {
                    // Mono
                    for (mo_uint32 iFrame = 0; iFrame < framesAvailable; ++iFrame) {
                        float scaledSample0 = pSound->pSource->raw.pSampleData[pSound->raw.currentSample + iFrame] * linearVolume;
                        float outputSample0 = pFrames[iFrame*deviceChannels + 0] + scaledSample0;
                        float outputSample1 = pFrames[iFrame*deviceChannels + 1] + scaledSample0;
                        pFrames[iFrame*deviceChannels + 0] = (mo_int16)(mo_clampf(outputSample0, -32768.0f, 32767.0f));
                        pFrames[iFrame*deviceChannels + 1] = (mo_int16)(mo_clampf(outputSample1, -32768.0f, 32767.0f));
                    }
                    pSound->raw.currentSample += framesAvailable * soundChannels;
                } else if (soundChannels == 2) {
                    // Stereo
                    for (mo_uint32 iFrame = 0; iFrame < framesAvailable; ++iFrame) {
                        float scaledSample0 = pSound->pSource->raw.pSampleData[pSound->raw.currentSample + iFrame*soundChannels + 0] * linearVolume;
                        float scaledSample1 = pSound->pSource->raw.pSampleData[pSound->raw.currentSample + iFrame*soundChannels + 1] * linearVolume;
                        float outputSample0 = pFrames[iFrame*deviceChannels + 0] + scaledSample0;
                        float outputSample1 = pFrames[iFrame*deviceChannels + 1] + scaledSample1;
                        pFrames[iFrame*deviceChannels + 0] = (mo_int16)(mo_clampf(outputSample0, -32768.0f, 32767.0f));
                        pFrames[iFrame*deviceChannels + 1] = (mo_int16)(mo_clampf(outputSample1, -32768.0f, 32767.0f));
                    }
                    pSound->raw.currentSample += framesAvailable * soundChannels;
                } else {
                    // More than stereo. Just drop the extra channels. This can be used for stereo sounds, but is not as optimized.
                    for (mo_uint32 iFrame = 0; iFrame < framesAvailable; ++iFrame) {
                        for (mo_uint32 iChannel = 0; iChannel < deviceChannels; ++iChannel) {
                            float scaledSample0 = pSound->pSource->raw.pSampleData[pSound->raw.currentSample + iFrame*soundChannels + iChannel] * linearVolume;
                            float outputSample0 = pFrames[iFrame*deviceChannels + iChannel] + scaledSample0;
                            pFrames[iFrame*deviceChannels + iChannel] = (mo_int16)(mo_clampf(outputSample0, -32768.0f, 32767.0f));
                        }
                    }
                    pSound->raw.currentSample += framesAvailable * soundChannels;
                }
            }


            mo_bool32 reachedEnd = framesAvailable < frameCount;
            frameCount -= (mo_uint32)framesAvailable;   // <-- Safe cast because we clamped it to frameCount which is 32-bit.
            pFrames += framesAvailable * deviceChannels;

            if (reachedEnd) {
                if (mo_sound_is_looping(pSound)) {
                    pSound->raw.currentSample = 0;
                } else {
                    if ((pSound->flags & MO_SOUND_FLAG_INLINED) != 0) {
                        mo_sound_mark_for_deletion(pSound);
                    } else {
                        mo_sound_stop(pSound);
                    }

                    break;
                }
            }
        }
    }
#ifdef MO_HAS_STB_VORBIS
    else if (pSource->type == mo_sound_source_type_vorbis)
    {
        // Conveniently, stb_vorbis supports sample retrieval with a custom channel count.
        const mo_uint32 deviceChannels = pSound->pContext->playbackDevice2.channels;
        const mo_uint32 soundChannels = deviceChannels;
        while (frameCount > 0) {
            mo_uint64 framesAvailable = frameCount;

            // We need to use an intermediary here. The process goes: stb_vorbis -> temp buffer -> sum with output.
            float tempFrames[4096];
            mo_uint32 tempFrameCount = sizeof(tempFrames) / sizeof(tempFrames[0]) / soundChannels;
            if (framesAvailable > tempFrameCount) {
                framesAvailable = tempFrameCount;
            }

            // This is used for later checking if we need to stop playback or loop back to the start.
            mo_bool32 reachedEnd = MO_FALSE;

            int framesRead = stb_vorbis_get_samples_float_interleaved((stb_vorbis*)pSound->vorbis.pDecoder, (int)deviceChannels, tempFrames, (int)(framesAvailable * deviceChannels));
            if (framesRead < (int)framesAvailable) {
                reachedEnd = MO_TRUE;
            }

            // Unroll this loop for stereo? Probably not worth it...
            for (mo_uint32 iSample = 0; iSample < framesRead*soundChannels; ++iSample) {
                float scaledSample0 = tempFrames[iSample]*32767.0f * linearVolume;
                float outputSample0 = pFrames[iSample] + scaledSample0;
                pFrames[iSample] = (mo_int16)(mo_clampf(outputSample0, -32768.0f, 32767.0f));
            }

            pSound->vorbis.currentSample += framesRead * soundChannels;
            frameCount -= (mo_uint32)framesAvailable;   // <-- Safe cast because we clamped it to frameCount which is 32-bit.
            pFrames += framesAvailable * deviceChannels;

            if (reachedEnd) {
                if (mo_sound_is_looping(pSound)) {
                    pSound->vorbis.currentSample = 0;
                    stb_vorbis_seek_start((stb_vorbis*)pSound->vorbis.pDecoder);
                } else {
                    if ((pSound->flags & MO_SOUND_FLAG_INLINED) != 0) {
                        mo_sound_mark_for_deletion(pSound);
                    } else {
                        mo_sound_stop(pSound);
                    }

                    break;
                }
            }
        }
    }
#endif
#ifdef MO_HAS_DR_FLAC
    else if (pSource->type == mo_sound_source_type_flac)
    {
        const mo_uint32 deviceChannels = pSound->pContext->playbackDevice2.channels;
        const mo_uint32 soundChannels = ((drflac*)pSound->flac.pDecoder)->channels;
        while (frameCount > 0) {
            mo_uint64 framesAvailable = frameCount;

            // We need to use an intermediary here. The process goes: dr_flac -> temp buffer -> sum with output.
            mo_int32 tempFrames[4096];
            mo_uint32 tempFrameCount = sizeof(tempFrames) / sizeof(tempFrames[0]) / soundChannels;
            if (framesAvailable > tempFrameCount) {
                framesAvailable = tempFrameCount;
            }

            // This is used for later checking if we need to stop playback or loop back to the start.
            mo_bool32 reachedEnd = MO_FALSE;

            dr_uint64 framesRead = drflac_read_s32((drflac*)pSound->flac.pDecoder, framesAvailable * soundChannels, tempFrames) / soundChannels;
            if (framesRead < framesAvailable) {
                reachedEnd = MO_TRUE;
            }


            // Channel conversion.
            if (deviceChannels == 1) {
                // Mono. For converting to mono all we do is just average each channel.
                for (mo_uint32 iFrame = 0; iFrame < framesAvailable; ++iFrame) {
                    float totalPCM = 0;
                    for (mo_uint32 iChannel = 0; iChannel < soundChannels; ++iChannel) {
                        totalPCM += (float)(tempFrames[iFrame*soundChannels + iChannel] >> 16);
                    }

                    float outputSample = pFrames[iFrame] + ((totalPCM / soundChannels) * linearVolume);
                    pFrames[iFrame] = (mo_int16)(mo_clampf(outputSample, -32768.0f, 32767.0f));
                }
            } else {
                // Stereo.
                if (soundChannels == 1) {
                    // Mono
                    for (mo_uint32 iFrame = 0; iFrame < framesRead; ++iFrame) {
                        float scaledSample0 = (tempFrames[iFrame*soundChannels + 0] >> 16) * linearVolume;
                        float outputSample0 = pFrames[iFrame*deviceChannels + 0] + scaledSample0;
                        float outputSample1 = pFrames[iFrame*deviceChannels + 1] + scaledSample0;
                        pFrames[iFrame*deviceChannels + 0] = (mo_int16)(mo_clampf(outputSample0, -32768.0f, 32767.0f));
                        pFrames[iFrame*deviceChannels + 1] = (mo_int16)(mo_clampf(outputSample1, -32768.0f, 32767.0f));
                    }
                } else if (soundChannels == 2) {
                    // Stereo
                    for (mo_uint32 iFrame = 0; iFrame < framesAvailable; ++iFrame) {
                        float scaledSample0 = (tempFrames[iFrame*soundChannels + 0] >> 16) * linearVolume;
                        float scaledSample1 = (tempFrames[iFrame*soundChannels + 1] >> 16) * linearVolume;
                        float outputSample0 = pFrames[iFrame*deviceChannels + 0] + scaledSample0;
                        float outputSample1 = pFrames[iFrame*deviceChannels + 1] + scaledSample1;
                        pFrames[iFrame*deviceChannels + 0] = (mo_int16)(mo_clampf(outputSample0, -32768.0f, 32767.0f));
                        pFrames[iFrame*deviceChannels + 1] = (mo_int16)(mo_clampf(outputSample1, -32768.0f, 32767.0f));
                    }
                } else {
                    // More than stereo. Just drop the extra channels. This can be used for stereo sounds, but is not as optimized.
                    for (mo_uint32 iFrame = 0; iFrame < framesAvailable; ++iFrame) {
                        for (mo_uint32 iChannel = 0; iChannel < deviceChannels; ++iChannel) {
                            float scaledSample0 = (tempFrames[iFrame*soundChannels + iChannel] >> 16) * linearVolume;
                            float outputSample0 = pFrames[iFrame*deviceChannels + iChannel] + scaledSample0;
                            pFrames[iFrame*deviceChannels + iChannel] = (mo_int16)(mo_clampf(outputSample0, -32768.0f, 32767.0f));
                        }
                    }
                }
            }


            pSound->flac.currentSample += framesRead * soundChannels;
            frameCount -= (mo_uint32)framesAvailable;   // <-- Safe cast because we clamped it to frameCount which is 32-bit.
            pFrames += framesAvailable * deviceChannels;

            if (reachedEnd) {
                if (mo_sound_is_looping(pSound)) {
                    pSound->flac.currentSample = 0;
                    drflac_seek_to_sample((drflac*)pSound->flac.pDecoder, 0);
                } else {
                    if ((pSound->flags & MO_SOUND_FLAG_INLINED) != 0) {
                        mo_sound_mark_for_deletion(pSound);
                    } else {
                        mo_sound_stop(pSound);
                    }

                    break;
                }
            }
        }
    }
#endif

    return totalFramesRead;
}

mal_uint32 mo_on_send_frames__mal(mal_device* pDevice, mal_uint32 frameCount, void* pFrames)
{
    // This is where all of our audio mixing is done.
    mo_context* pContext = (mo_context*)pDevice->pUserData;
    mo_assert(pContext != NULL);

    // The output buffer is in s16 format.
    mo_int16* pFramesS16 = (mal_int16*)pFrames;
    mo_assert(pFramesS16 != NULL);

    // Mixing is easy - we just need to accumulate each sound, making sure we adjust for volume. If a sound reaches
    // the end of it's data source we need to either loop or stop the sound.

    // Important that we clear the output buffer to zero since we'll be accumulating.
    mo_zero_memory(pFrames, frameCount * pDevice->channels * sizeof(mo_int16));

    for (mo_uint32 iSound = 0; iSound < pContext->soundCount; ++iSound) {
        mo_sound* pSound = pContext->ppSounds[iSound];
        if (mo_sound_is_playing(pSound) && !mo_sound_group_is_paused(pContext, pSound->group)) {
            float linearVolume = pSound->linearVolume * pContext->soundGroups[pSound->group].linearVolume * pContext->soundGroups[MO_SOUND_GROUP_MASTER].linearVolume;
            if (linearVolume > 0) {
                mo_sound__read_and_accumulate_frames(pSound, linearVolume, frameCount, pFramesS16);
            }
        }
    }

    return frameCount;
}

mo_result mo_init_audio(mo_context* pContext)
{
    mo_assert(pContext != NULL);

    // Sound groups.
    for (int i = 0; i < MO_SOUND_GROUP_COUNT; ++i) {
        pContext->soundGroups[i].linearVolume = 1;
    }

    mal_context_config contextConfig = mal_context_config_init(
        mo_on_log__mal
    );

    mal_device_config deviceConfig = mal_device_config_init_playback(
        mal_format_s16,
        pContext->profile.audioChannels,
        pContext->profile.audioSampleRate,
        mo_on_send_frames__mal
    );
    
    mal_result resultMAL = mal_device_init_ex(NULL, 0, &contextConfig, mal_device_type_playback, NULL, &deviceConfig, pContext, &pContext->playbackDevice2);
    if (resultMAL != MAL_SUCCESS) {
        return MO_ERROR;
    }

    // Start the device now, but we might want to make this a bit more intelligent and only have the
    // device running while a sound needs to be played.
    mal_device_start(&pContext->playbackDevice2);

    return MO_SUCCESS;
}

void mo_uninit_audio(mo_context* pContext)
{
    mo_assert(pContext != NULL);

    mal_device_uninit(&pContext->playbackDevice2);
}


mo_color_rgba mo_make_rgba(mo_uint8 r, mo_uint8 g, mo_uint8 b, mo_uint8 a)
{
    mo_color_rgba result;
    result.b = b;
    result.g = g;
    result.r = r;
    result.a = a;
    return result;
}

mo_color_rgba mo_make_rgb(mo_uint8 r, mo_uint8 g, mo_uint8 b)
{
    return mo_make_rgba(r, g, b, 255);
}

mo_result mo_init(mo_profile* pProfile, mo_uint32 windowSizeX, mo_uint32 windowSizeY, const char* title, mo_on_step_proc onStep, void* pUserData, mo_context** ppContext)
{
    if (ppContext == NULL) return MO_INVALID_ARGS;
    mo_zero_object(ppContext);

    mo_profile defaultProfile;
    defaultProfile.resolutionX = 160;
    defaultProfile.resolutionY = 144;
    defaultProfile.transparentColorIndex = 255;
    defaultProfile.paletteSize = 256;
    mo_copy_memory(defaultProfile.palette, g_moDefaultPalette, 256*4);
    defaultProfile.audioChannels = 2;
    defaultProfile.audioSampleRate = 44100;
    if (pProfile == NULL) pProfile = &defaultProfile;
    if (pProfile->paletteSize == 0) return MO_BAD_PROFILE;
    if (pProfile->transparentColorIndex >= pProfile->paletteSize) return MO_BAD_PROFILE;

    if (pProfile->audioSampleRate == 0) pProfile->audioSampleRate = 44100;
    if (pProfile->audioChannels == 0) pProfile->audioChannels = 2;

    // For now, only supporting mono and stereo.
    if (pProfile->audioChannels > 2) {
        pProfile->audioChannels = 2;
    }

    if (windowSizeX == 0) windowSizeX = pProfile->resolutionX;
    if (windowSizeY == 0) windowSizeY = pProfile->resolutionY;
    if (title == NULL) title = "Mintaro";

    size_t screenSizeInBytes = pProfile->resolutionX * pProfile->resolutionY * sizeof(mo_color_index);
    size_t contextSize = sizeof(mo_context) + screenSizeInBytes;

    mo_context* pContext = (mo_context*)mo_calloc(contextSize);
    if (pContext == NULL) {
        return MO_OUT_OF_MEMORY;
    }

    pContext->onStep = onStep;
    pContext->pUserData = pUserData;
    pContext->profile = *pProfile;
    pContext->screen = pContext->pExtraData;

    // The window.
#ifdef MO_WIN32
    if (mo_atomic_increment(&g_MintaroInitCounter) == 1) {
        WNDCLASSEXA wc;
        ZeroMemory(&wc, sizeof(wc));
        wc.cbSize        = sizeof(wc);
        wc.cbWndExtra    = sizeof(void*);
        wc.lpfnWndProc   = (WNDPROC)DefaultWindowProcWin32;
        wc.lpszClassName = g_MintaroWndClassName;
        wc.hCursor       = LoadCursorA(NULL, MAKEINTRESOURCEA(32512));
        wc.style         = CS_OWNDC | CS_DBLCLKS;
        if (!RegisterClassExA(&wc)) {
            mo_free(pContext);
            return MO_FAILED_TO_INIT_PLATFORM;   // Failed to initialize the window class.
        }
    }


    DWORD dwExStyle = 0;
    DWORD dwStyle = WS_OVERLAPPEDWINDOW;
    pContext->hWnd = CreateWindowExA(dwExStyle, g_MintaroWndClassName, title, dwStyle, CW_USEDEFAULT, CW_USEDEFAULT, windowSizeX, windowSizeY, NULL, NULL, NULL, NULL);
    if (pContext->hWnd == NULL) {
        mo_uninit(pContext);
        return MO_FAILED_TO_INIT_PLATFORM;
    }

    // Cache the DC so we can avoid GetDC().
    pContext->hDC = GetDC(pContext->hWnd);

    // The context needs to be linked to the Win32 window handle so it can be accessed from the event handler.
    SetWindowLongPtrA(pContext->hWnd, 0, (LONG_PTR)pContext);

    // We should have a window, but before showing it we need to make a few small adjustments to the size such that the client size
    // is equal to resolutionX and resolutionY. When we created the window, we specified resolutionX and resolutionY as the dimensions,
    // however this includes the size of the outer border. The outer border should not be included, so we need to stretch the window
    // just a little bit such that the area inside the borders are exactly equal to resolutionX and resolutionY.
    RECT windowRect;
    RECT clientRect;
    GetWindowRect(pContext->hWnd, &windowRect);
    GetClientRect(pContext->hWnd, &clientRect);

    pContext->windowWidth  = (int)windowSizeX + ((windowRect.right - windowRect.left) - (clientRect.right - clientRect.left));
    pContext->windowHeight = (int)windowSizeY + ((windowRect.bottom - windowRect.top) - (clientRect.bottom - clientRect.top));
    SetWindowPos(pContext->hWnd, NULL, 0, 0, pContext->windowWidth, pContext->windowHeight, SWP_NOZORDER | SWP_NOMOVE);


    // We need a DIB section for drawing the screen to the Win32 window.
    pContext->hDIBDC = CreateCompatibleDC(pContext->hDC);
    if (pContext->hDIBDC == NULL) {
        mo_uninit(pContext);
        return MO_FAILED_TO_INIT_PLATFORM;
    }

    BITMAPINFO bmi;
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
    bmi.bmiHeader.biWidth = pProfile->resolutionX;
    bmi.bmiHeader.biHeight = -(int)pProfile->resolutionY;     // <-- Making this negative makes it top-down.
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    pContext->hDIBSection = CreateDIBSection(pContext->hDIBDC, &bmi, DIB_RGB_COLORS, &pContext->pScreenRGBA_DIB, NULL, 0);
    if (pContext->hDIBSection == NULL) {
        mo_uninit(pContext);
        return MO_FAILED_TO_INIT_PLATFORM;
    }

    SelectObject(pContext->hDIBDC, pContext->hDIBSection);

    ShowWindow(pContext->hWnd, SW_SHOWNORMAL);
#endif

#ifdef MO_X11
    if (mo_atomic_increment(&g_MintaroInitCounter) == 1) {
        //assert(g_moX11Display == NULL);
        g_moX11Display = XOpenDisplay(NULL);
        if (g_moX11Display == NULL) {
            mo_free(pContext);
            return MO_FAILED_TO_INIT_PLATFORM;
        }

        g_WM_DELETE_WINDOW = XInternAtom(g_moX11Display, "WM_DELETE_WINDOW", False);
        g_Atom_moWindow = XInternAtom(g_moX11Display, "ATOM_moWindow", False);
    }

    int blackColor = BlackPixel(g_moX11Display, DefaultScreen(g_moX11Display));
    int whiteColor = WhitePixel(g_moX11Display, DefaultScreen(g_moX11Display));

    pContext->windowX11 = XCreateSimpleWindow(g_moX11Display, DefaultRootWindow(g_moX11Display),
        0, 0, windowSizeX, windowSizeY, 0, blackColor, blackColor);
    if (pContext->windowX11 == 0) {
        mo_uninit(pContext);
        return MO_FAILED_TO_INIT_PLATFORM;
    }

    mo_set_x11_window_property(g_moX11Display, pContext->windowX11, g_Atom_moWindow, pContext);

    XSelectInput(g_moX11Display, pContext->windowX11, ExposureMask | StructureNotifyMask | KeyPressMask | KeyReleaseMask);
    XSetWMProtocols(g_moX11Display, pContext->windowX11, &g_WM_DELETE_WINDOW, 1);
    XStoreName(g_moX11Display, pContext->windowX11, title);
    XMapRaised(g_moX11Display, pContext->windowX11);

    pContext->gcX11 = XCreateGC(g_moX11Display, pContext->windowX11, 0, NULL);
    if (pContext->gcX11 == 0) {
        mo_uninit(pContext);
        return MO_FAILED_TO_INIT_PLATFORM;
    }

    // By default every KeyPress event is matched with a KeyRelease event even when the use hasn't
    // actually released the key. This call makes it so the KeyRelease event is only posted when the
    // user has actually released the key.
    XkbSetDetectableAutoRepeat(g_moX11Display, True, NULL);

    // We want to use the MIT-SHM extension if it's available.
    if (XShmQueryExtension(g_moX11Display)) {
        pContext->flags |= MO_FLAG_X11_USING_SHM;
    }
#endif

    // Audio.
    mo_result result = mo_init_audio(pContext);
    if (result != MO_SUCCESS) {
        mo_uninit(pContext);
        return result;
    }


    // Default key bindings.
    mo_bind_key_to_button(pContext, MO_KEY_ARROW_LEFT, MO_BUTTON_LEFT);
    mo_bind_key_to_button(pContext, MO_KEY_ARROW_UP, MO_BUTTON_UP);
    mo_bind_key_to_button(pContext, MO_KEY_ARROW_RIGHT, MO_BUTTON_RIGHT);
    mo_bind_key_to_button(pContext, MO_KEY_ARROW_DOWN, MO_BUTTON_DOWN);
    mo_bind_key_to_button(pContext, 'Z', MO_BUTTON_A);
    mo_bind_key_to_button(pContext, 'X', MO_BUTTON_B);
    mo_bind_key_to_button(pContext, MO_KEY_SPACE, MO_BUTTON_SELECT);
    mo_bind_key_to_button(pContext, MO_KEY_ENTER, MO_BUTTON_START);

    // Timer.
    mo_timer_init(&pContext->timer);

    *ppContext = pContext;
    return MO_SUCCESS;
}

void mo_uninit(mo_context* pContext)
{
    if (pContext == NULL) return;

    mo_uninit_audio(pContext);

#ifdef MO_WIN32
    if (pContext->hDIBSection) {
        DeleteObject(pContext->hDIBSection);
    }
    if (pContext->hDIBDC) {
        DeleteDC(pContext->hDIBDC);
    }
    if (pContext->hWnd) {
        DestroyWindow(pContext->hWnd);
    }
    if (mo_atomic_decrement(&g_MintaroInitCounter) == 0) {
        UnregisterClassA(g_MintaroWndClassName, GetModuleHandleA(NULL));
    }
#endif

#ifdef MO_X11
    if (pContext->gcX11) {
        XFreeGC(g_moX11Display, pContext->gcX11);
    }
    if (pContext->windowX11) {
        XDestroyWindow(g_moX11Display, pContext->windowX11);
    }
    if (mo_atomic_decrement(&g_MintaroInitCounter) == 0) {
        XCloseDisplay(g_moX11Display);
    }
#endif

    mo_free(pContext);
}

void mo_present(mo_context* pContext)
{
    if (pContext == NULL) return;

#ifdef MO_WIN32
    // Conveniently, we can get Win32 to do the scaling for us. This means we're able to do an efficient 1x1 copy ourselves and then
    // let the OS do the rest for us. Of course, there's a chance we could do it more efficiently ourselves, but maybe not.

    // OPTIMIZATION NOTES
    // ==================
    // - It's more efficient to flip the screen ourselves than passing in a negative height to StretchDIBits().
    // - CreateDIBSection() + StretchBlt() is more efficient than StretchDIBits() by a tiny amount.
    // - BitBlt() is a tiny bit faster than StretchBlt(), but it's less than a microsecond. Probably not worth it.
    //
    // THINGS TO TRY
    // -------------
    // [DONE] Try using a palette (DIB_PAL_COLORS).
    //     RESULT: Couldn't figure out how to get it working properly. Probably not worthwhile.

#if 0
    BITMAPINFO bmi;
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
    bmi.bmiHeader.biWidth = screenWidth;
    bmi.bmiHeader.biHeight = screenHeight;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    for (int y = 0; y < screenHeight; ++y) {
        mo_uint32* pDstRow = ((mo_uint32*)pContext->pScreenRGBA) + (y * screenWidth);
        for (int x = 0; x < screenWidth; ++x) {
            unsigned int screenX = x;
            unsigned int screenY = y;
            //pDstRow[x] = pContext->palette[(pContext->screen[screenY][screenX] & 0x03)].rgba;
            pDstRow[x] = pContext->palette[pContext->screen[screenHeight - screenY - 1][screenX]].rgba;    // <-- Needs to be upside down for Win32. Can also use a negative scale in StretchDIBits()
        }
    }

    // Note how the height and Y position is flipped in order to make it the right way around.
    //
    // Questions:
    //   - Does flipping upside down force it down a slower path? A) Yes, it's slower.
    //StretchDIBits(pContext->hDC, 0, pContext->windowHeight-1, pContext->windowWidth, -pContext->windowHeight, 0, 0, screenWidth, screenHeight, pContext->pScreenRGBA, &bmi, DIB_RGB_COLORS, SRCCOPY);
    StretchDIBits(pContext->hDC, 0, 0, pContext->windowWidth, pContext->windowHeight, 0, 0, screenWidth, screenHeight, pContext->pScreenRGBA, &bmi, DIB_RGB_COLORS, SRCCOPY);
#else
    // Before writing the data to the DIB section we need to flush GDI.
    //GdiFlush();

    for (unsigned int y = 0; y < pContext->profile.resolutionY; ++y) {
        mo_uint32* pDstRow = ((mo_uint32*)pContext->pScreenRGBA_DIB) + (y * pContext->profile.resolutionX);
        for (unsigned int x = 0; x < pContext->profile.resolutionX; ++x) {
            unsigned int screenX = x;
            unsigned int screenY = y;
            pDstRow[x] = pContext->profile.palette[pContext->screen[screenY*pContext->profile.resolutionX + screenX]].rgba;
        }
    }

    StretchBlt(pContext->hDC, 0, 0, pContext->windowWidth, pContext->windowHeight, pContext->hDIBDC, 0, 0, pContext->profile.resolutionX, pContext->profile.resolutionY, SRCCOPY);
#endif
#endif

#ifdef MO_X11
    // OPTIMZATION NOTES
    // =================
    // - The MIT-SHM extension using XShmPutImage() is about 7 microseconds faster than XPutImage() @ 160x144.
    //
    //
    // THINGS TO TRY
    // -------------
    // [DONE] MIT-SHM Extension: https://linux.die.net/man/3/xshmputimage
    //     RESULT: A good optimization. About 7 microseconds faster @ 160x144 and scales with higher resolutions.

    if (pContext->pPresentBufferX11 == NULL) return;

    unsigned int dstSizeX = pContext->pPresentBufferX11->width;
    unsigned int dstSizeY = pContext->pPresentBufferX11->height;
    unsigned int srcSizeX = pContext->profile.resolutionX;
    unsigned int srcSizeY = pContext->profile.resolutionY;

    float ratioX = (float)srcSizeX / dstSizeX;
    float ratioY = (float)srcSizeY / dstSizeY;

    for (int y = 0; y < dstSizeY; ++y) {
        mo_uint32* pDstRow = ((mo_uint32*)pContext->pPresentBufferX11->data) + (y * dstSizeX);
        for (int x = 0; x < dstSizeX; ++x) {
            unsigned int screenX = (unsigned int)(x*ratioX);
            unsigned int screenY = (unsigned int)(y*ratioY);

            pDstRow[x] = pContext->profile.palette[pContext->screen[screenY*pContext->profile.resolutionX + screenX]].rgba;
        }
    }

    mo_x11_present(pContext);
#endif
}

#ifdef MO_X11
static mo_key mo_convert_key_code__x11(unsigned int keycode)
{
    KeySym key = XkbKeycodeToKeysym(g_moX11Display, keycode, 0, 1);
    switch (key)
    {
        case XK_BackSpace: return MO_KEY_BACKSPACE;
        case XK_Return:    return MO_KEY_ENTER;
        case XK_Shift_L:   return MO_KEY_SHIFT;
        case XK_Shift_R:   return MO_KEY_SHIFT;
        case XK_Escape:    return MO_KEY_ESCAPE;
        case XK_space:     return MO_KEY_SPACE;
        case XK_Page_Up:   return MO_KEY_PAGE_UP;
        case XK_Page_Down: return MO_KEY_PAGE_DOWN;
        case XK_End:       return MO_KEY_END;
        case XK_Home:      return MO_KEY_HOME;
        case XK_Left:      return MO_KEY_ARROW_LEFT;
        case XK_Up:        return MO_KEY_ARROW_UP;
        case XK_Right:     return MO_KEY_ARROW_RIGHT;
        case XK_Down:      return MO_KEY_ARROW_DOWN;
        case XK_Delete:    return MO_KEY_DELETE;
        case XK_F1:        return MO_KEY_F1;
        case XK_F2:        return MO_KEY_F2;
        case XK_F3:        return MO_KEY_F3;
        case XK_F4:        return MO_KEY_F4;
        case XK_F5:        return MO_KEY_F5;
        case XK_F6:        return MO_KEY_F6;
        case XK_F7:        return MO_KEY_F7;
        case XK_F8:        return MO_KEY_F8;
        case XK_F9:        return MO_KEY_F9;
        case XK_F10:       return MO_KEY_F10;
        case XK_F11:       return MO_KEY_F11;
        case XK_F12:       return MO_KEY_F12;
        default: break;
    }

    return (mo_key)key;
}

void mo_handle_x11_event(XEvent* ex)
{
    mo_context* pContext = (mo_context*)mo_get_x11_window_property(g_moX11Display, ex->xany.window, g_Atom_moWindow);
    if (pContext == NULL) {
        return;
    }

    switch (ex->type)
    {
        case ConfigureNotify:
        {
            if (pContext->pPresentBufferX11 == NULL || (pContext->pPresentBufferX11->width != ex->xconfigure.width || pContext->pPresentBufferX11->height != ex->xconfigure.height)) {
                mo_x11_resize_presentation_buffer(pContext, ex->xconfigure.width, ex->xconfigure.height);
            }
        } break;


        case MotionNotify:
        {
        } break;

        case ButtonPress:
        {
        } break;

        case ButtonRelease:
        {
        } break;


        case KeyPress:
        {
            mo__on_button_down(pContext, mo_get_key_binding(pContext, mo_convert_key_code__x11(ex->xkey.keycode)));
        } break;

        case KeyRelease:
        {
            mo__on_button_up(pContext, mo_get_key_binding(pContext, mo_convert_key_code__x11(ex->xkey.keycode)));
        } break;


        case Expose:
        {
            // We need to present the screen to the window. To do this we need to write the
            // data to an XImage object and then call XPutImage() to copy the image over to
            // the window.
            mo_present(pContext);
            XFlush(g_moX11Display); // <-- Is this needed? Assuming so because I saw it in an example, but not sure.
        } break;


        default: break;
    }
}
#endif

int mo_run(mo_context* pContext)
{
    if (pContext == NULL) return MO_INVALID_ARGS;

    while ((pContext->flags & MO_FLAG_CLOSING) == 0) {
        // Handle window events first.
#ifdef MO_WIN32
        MSG msg;
        if (PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT) {
                return (int)msg.wParam;  // Received a quit message.
            }

            TranslateMessage(&msg);
            DispatchMessageA(&msg);
        }
#endif

#ifdef MO_X11
        if (XPending(g_moX11Display) > 0) {   // <-- Use a while loop instead?
            XEvent x11Event;
            XNextEvent(g_moX11Display, &x11Event);

            if (x11Event.type == ClientMessage) {
                if ((Atom)x11Event.xclient.data.l[0] == g_WM_DELETE_WINDOW) {
                    return 0;   // Received a quit message.
                }
            };

            mo_handle_x11_event(&x11Event);
        }
#endif

        // Now just step the game.
        double dt = mo_timer_tick(&pContext->timer);
        if (pContext->onStep) {
            pContext->onStep(pContext, dt);

            pContext->buttonPressState = 0;
            pContext->buttonReleaseState = 0;
        }

        // Collect garbage.
        if (pContext->isSoundMarkedForDeletion) {
            for (size_t iSound = 0; iSound < pContext->soundCount; /* DO NOTHING */) {
                if (pContext->ppSounds[iSound]->isMarkedForDeletion) {
                    mo_sound_delete(pContext->ppSounds[iSound]);
                } else {
                    iSound += 1;
                }
            }
        }

        // Present the screen to the window.
        mo_present(pContext);
    }

    return 0;
}

void mo_close(mo_context* pContext)
{
    if (pContext == NULL) return;

#ifdef MO_WIN32
    PostQuitMessage(0);
#endif

    pContext->flags |= MO_FLAG_CLOSING;
}

void mo_log(mo_context* pContext, const char* message)
{
    if (pContext == NULL || pContext->onLog == NULL) return;
    pContext->onLog(pContext, message);
}

void mo_logf(mo_context* pContext, const char* format, ...)
{
    va_list args;

    va_start(args, format);
#if defined(_MSC_VER)
    int len = _vscprintf(format, args);
#else
    int len = vsnprintf(NULL, 0, format, args);
#endif
    va_end(args);

    if (len < 0) {
        return;
    }

    char* message = (char*)mo_malloc(len+1);
    if (message == NULL) {
        va_end(args);
        return;
    }

    va_start(args, format);
#if defined(_MSC_VER)
    len = vsprintf_s(message, len+1, format, args);
#else
    len = vsnprintf(message, len+1, format, args);
#endif
    va_end(args);

    mo_log(pContext, message);

    mo_free(message);
    va_end(args);
}


//// Resources ////

static const char* mo_file_name(const char* path)
{
    if (path == NULL) {
        return NULL;
    }

    const char* fileName = path;

    // We just loop through the path until we find the last slash.
    while (path[0] != '\0') {
        if (path[0] == '/' || path[0] == '\\') {
            fileName = path;
        }

        path += 1;
    }

    // At this point the file name is sitting on a slash, so just move forward.
    while (fileName[0] != '\0' && (fileName[0] == '/' || fileName[0] == '\\')) {
        fileName += 1;
    }

    return fileName;
}

static const char* mo_extension(const char* path)
{
    if (path == NULL) {
        return NULL;
    }

    const char* extension     = mo_file_name(path);
    const char* lastoccurance = 0;

    // Just find the last '.' and return.
    while (extension[0] != '\0')
    {
        if (extension[0] == '.') {
            extension    += 1;
            lastoccurance = extension;
        }

        extension += 1;
    }

    return (lastoccurance != 0) ? lastoccurance : extension;
}

static mo_bool32 mo_extension_equal(const char* path, const char* extension)
{
    if (path == NULL || extension == NULL) {
        return MO_FALSE;
    }

    const char* ext1 = extension;
    const char* ext2 = mo_extension(path);

#ifdef _MSC_VER
    return _stricmp(ext1, ext2) == 0;
#else
    return strcasecmp(ext1, ext2) == 0;
#endif
}

static void* mo_open_and_read_file_with_extra_data(mo_context* pContext, const char* filePath, size_t* pFileSizeOut, size_t extraBytes)
{
    if (pFileSizeOut) *pFileSizeOut = 0;   // For safety.

    if (filePath == NULL) {
        return NULL;
    }

#ifdef MO_WIN32
    HANDLE hFile = CreateFileA(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        mo_logf(pContext, "Could not find file: %s", filePath);
        return NULL;
    }

    LARGE_INTEGER fileSize;
    if (!GetFileSizeEx(hFile, &fileSize) || ((fileSize.QuadPart + extraBytes) > 0xFFFFFFFF)) {
        mo_logf(pContext, "File is too large: %s", filePath);
        CloseHandle(hFile);
        return NULL;
    }

    void* pFileData = mo_malloc(fileSize.LowPart + extraBytes);
    if (pFileData == NULL) {
        mo_logf(pContext, "Not enough memory to load image: %s", filePath);
        CloseHandle(hFile);
        return NULL;
    }

    DWORD bytesRead;
    if (!ReadFile(hFile, pFileData, fileSize.LowPart, &bytesRead, NULL) || bytesRead != fileSize.LowPart) {
        mo_logf(pContext, "Failed to read image file: %s", filePath);
        mo_free(pFileData);
        CloseHandle(hFile);
        return NULL;
    }

    CloseHandle(hFile);

    if (pFileSizeOut) *pFileSizeOut = (unsigned int)fileSize.LowPart;
    return pFileData;
#endif

#ifdef MO_POSIX
    int fd = open(filePath, O_RDONLY, 0666);
    if (fd == -1) {
        mo_logf(pContext, "Could not find file: %s", filePath);
        return NULL;
    }

    struct stat info;
    if (fstat(fd, &info) == -1) {
        mo_logf(pContext, "Failed to retrieve file info: %s", filePath);
        close(fd);
        return NULL;
    }

    if (info.st_size + extraBytes > 0xFFFFFFFF) {
        mo_logf(pContext, "File is too large: %s", filePath);
        close(fd);
        return NULL;    // File is too big.
    }

    void* pFileData = mo_malloc(info.st_size + extraBytes);
    if (pFileData == NULL) {
        mo_logf(pContext, "Not enough memory to load image: %s", filePath);
        close(fd);
        return NULL;
    }

    ssize_t bytesRead = read(fd, pFileData, info.st_size);
    if (bytesRead != info.st_size) {
        mo_logf(pContext, "Failed to read image file: %s", filePath);
        mo_free(pFileData);
        close(fd);
        return NULL;
    }

    close(fd);

    if (pFileSizeOut) *pFileSizeOut = (unsigned int)info.st_size;
    return pFileData;
#endif
}

static void* mo_open_and_read_file(mo_context* pContext, const char* filePath, size_t* pFileSizeOut)
{
    return mo_open_and_read_file_with_extra_data(pContext, filePath, pFileSizeOut, 0);
}

mo_result mo_image_create(mo_context* pContext, unsigned int width, unsigned int height, mo_image_format format, const void* pData, mo_image** ppImage)
{
    if (ppImage == NULL) return MO_INVALID_ARGS;
    mo_zero_object(ppImage);

    if (pContext == NULL || width == 0 || height == 0 || pData == NULL) return MO_INVALID_ARGS;

    // Allocate the image first so we have an output buffer.
    size_t dataSize = width * height;
    mo_image* pImage = (mo_image*)mo_calloc((sizeof(*pImage)-1) + dataSize);
    if (pImage == NULL) {
        return MO_OUT_OF_MEMORY;
    }

    pImage->width = width;
    pImage->height = height;
    pImage->format = format;

    switch (format)
    {
        case mo_image_format_rgba8:
        {
            mo_color_rgba colorIn;

            const mo_uint8* pRunningPixel = (const mo_uint8*)pData;
            for (unsigned int y = 0; y < height; ++y) {
                for (unsigned int x = 0; x < width; ++x) {
                    colorIn.r = pRunningPixel[0];
                    colorIn.g = pRunningPixel[1];
                    colorIn.b = pRunningPixel[2];
                    colorIn.a = pRunningPixel[3];
                    mo_color_index colorIndex = mo_find_closest_color(pContext, colorIn);

                    // Set the transparent bit.
                    if (colorIn.a < 255) {
                        colorIndex = pContext->profile.transparentColorIndex;
                    }

                    pImage->pData[y*width + x] = colorIndex;
                    pRunningPixel += 4;
                }
            }
        } break;

        case mo_image_format_native:
        {
            mo_copy_memory(pImage->pData, pData, dataSize);
        } break;

        default:
        {
            return MO_UNSUPPORTED_IMAGE_FORMAT;
        } break;
    }

    *ppImage = pImage;
    return MO_SUCCESS;
}

static const void* mo_image_load__native(const void* pFileData, size_t fileSize, unsigned int* pWidthOut, unsigned int* pHeightOut, mo_image_format* pFormat)
{
    // The native image format is simple:
    // [4 bytes] FOURCC 'MOI1' (0x31494F4D)
    // [4 bytes] Width
    // [4 bytes] Height
    // [Width x Height bytes] Pixel data as 8-bit color indices. 1 byte per pixel, tightly packed, top down.

    if (pWidthOut  != NULL) *pWidthOut  = 0;
    if (pHeightOut != NULL) *pHeightOut = 0;
    if (pFormat    != NULL) *pFormat    = mo_image_format_unknown;
    if (pFileData == NULL || fileSize < 12) return NULL;

    const mo_uint8* pFileData8 = (const mo_uint8*)pFileData;

    mo_uint32 fourcc;
    mo_copy_memory(&fourcc, pFileData8 + 0, 4);
    if (fourcc != 0x31494F4D) {
        return NULL;    // Not a native image format.
    }

    mo_uint32 width;
    mo_uint32 height;
    mo_copy_memory(&width, pFileData8 + 4, 4);
    mo_copy_memory(&height, pFileData8 + 8, 4);

    if (pWidthOut  != NULL) *pWidthOut  = (unsigned int)width;
    if (pHeightOut != NULL) *pHeightOut = (unsigned int)height;
    if (pFormat    != NULL) *pFormat    = mo_image_format_native;
    return pFileData8 + 12;
}

static void* mo_image_load__tga(const void* pFileData, size_t fileSize, unsigned int* pWidthOut, unsigned int* pHeightOut, mo_image_format* pFormat)
{
    if (pWidthOut  != NULL) *pWidthOut  = 0;
    if (pHeightOut != NULL) *pHeightOut = 0;
    if (pFormat    != NULL) *pFormat    = mo_image_format_unknown;
    if (pFileData == NULL || fileSize < 18) return NULL;

    const mo_uint8* pFileData8 = (const mo_uint8*)pFileData;

    mo_uint8 idlen;
    mo_uint8 colormapType;
    mo_uint8 imageDataType;
    mo_int16 colormapOrigin;
    mo_int16 colormapLength;
    mo_uint8 colormapDepth;
    mo_int16 originX;
    mo_int16 originY;
    mo_int16 width;
    mo_int16 height;
    mo_uint8 bitsPerPixel;
    mo_uint8 descriptor;
    mo_copy_memory(&idlen,          pFileData8 + 0,  1);
    mo_copy_memory(&colormapType,   pFileData8 + 1,  1);
    mo_copy_memory(&imageDataType,  pFileData8 + 2,  1);
    mo_copy_memory(&colormapOrigin, pFileData8 + 3,  2);
    mo_copy_memory(&colormapLength, pFileData8 + 5,  2);
    mo_copy_memory(&colormapDepth,  pFileData8 + 7,  1);
    mo_copy_memory(&originX,        pFileData8 + 8,  2);
    mo_copy_memory(&originY,        pFileData8 + 10, 2);
    mo_copy_memory(&width,          pFileData8 + 12, 2);
    mo_copy_memory(&height,         pFileData8 + 14, 2);
    mo_copy_memory(&bitsPerPixel,   pFileData8 + 16, 1);
    mo_copy_memory(&descriptor,     pFileData8 + 17, 1);

    mo_uint32 flipY = (descriptor >> 5) & 1;

    mo_uint8 alphaMask = 0;
    if ((descriptor & 0x0F) == 0 || bitsPerPixel == 15 || colormapDepth == 15) {
        alphaMask = 0xFF;
    }

    // It's possible for the bits per pixel to be 15. In this case it appears that the data is still stored
    // as 16-bits in the file, but the the alpha bit is simply not used (everything is opaque).
    mo_uint8 bytesPerPixel = bitsPerPixel/8;
    if (bitsPerPixel == 15) {
        bytesPerPixel = 2;
    }

    // Go past the id.
    if (fileSize < 18U + idlen) {
        return NULL;
    }

    pFileData8 += 18+idlen; fileSize -= 18+idlen;

    // The colormap.
    const mo_uint8* pColormap8 = pFileData8;
    if (colormapType != 0) {
        size_t bytesToSkip = colormapLength * (colormapDepth/8);
        if (fileSize < bytesToSkip) {
            return NULL;
        }
        pFileData8 += bytesToSkip; fileSize -= bytesToSkip;
    }

    mo_uint8 colormapBytesPerPixel = colormapDepth/8;
    if (colormapDepth == 15) {
        colormapBytesPerPixel = 2;
    }


    mo_uint8* pImageData = (mo_uint8*)mo_malloc(width*height*4);
    if (pImageData == NULL) {
        return NULL;    // Out of memory :(
    }

    switch (imageDataType)
    {
        case 1:     // Uncompressed colormapped.
        {
            if (bytesPerPixel != 1 && bytesPerPixel != 2) {
                goto free_and_return_null;
            }

            size_t srcRowSizeInBytes = width*bytesPerPixel;
            if (fileSize < srcRowSizeInBytes*height) {
                goto free_and_return_null;  // File is too small.
            }

            for (mo_int16 y = 0; y < height; ++y) {
                mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                for (mo_int16 x = 0; x < width; ++x) {
                    mo_uint16 colorIndex = colormapOrigin;
                    if (bytesPerPixel == 1) {
                        colorIndex += pFileData8[0];
                    } else if (bytesPerPixel == 2) {
                        colorIndex += ((mo_uint16*)pFileData8)[0];
                    }

                    pFileData8 += bytesPerPixel;

                    // Grab the color from the colormap.
                    mo_uint8 r = 0;
                    mo_uint8 g = 0;
                    mo_uint8 b = 0;
                    mo_uint8 a = 255;
                    if (colormapBytesPerPixel == 4) {
                        r = pColormap8[colorIndex*4 + 2];
                        g = pColormap8[colorIndex*4 + 1];
                        b = pColormap8[colorIndex*4 + 0];
                        a = pColormap8[colorIndex*4 + 3] | alphaMask;
                    } else if (colormapBytesPerPixel == 3) {
                        r = pColormap8[colorIndex*3 + 2];
                        g = pColormap8[colorIndex*3 + 1];
                        b = pColormap8[colorIndex*3 + 0];
                    } else if (colormapBytesPerPixel == 2) {
                        mo_uint8 b0 = pColormap8[colorIndex*2 + 0];
                        mo_uint8 b1 = pColormap8[colorIndex*2 + 1];
                        r =  (((b1 & 0x7C) >> 2)                       * 255) / 31;
                        g = ((((b0 & 0xE0) >> 5) | ((b1 & 0x03) << 3)) * 255) / 31;
                        b =   ((b0 & 0x1F)                             * 255) / 31;
                        a =  (((b1 & 0x80) >> 7)                       * 255) | alphaMask;
                    }

                    pRow[(x*4)+0] = r;
                    pRow[(x*4)+1] = g;
                    pRow[(x*4)+2] = b;
                    pRow[(x*4)+3] = a;
                }
            }
        } break;

        case 2:     // Uncompressed RGB(A)
        {
            size_t srcRowSizeInBytes = width*bytesPerPixel;
            if (fileSize < srcRowSizeInBytes*height) {
                goto free_and_return_null;  // File is too small.
            }

            // We should now be sitting on the image data.
            if (bytesPerPixel == 4) {
                for (mo_int16 y = 0; y < height; ++y) {
                    mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                    for (mo_int16 x = 0; x < width; ++x) {
                        pRow[(x*4)+0] = pFileData8[(x*4)+2];
                        pRow[(x*4)+1] = pFileData8[(x*4)+1];
                        pRow[(x*4)+2] = pFileData8[(x*4)+0];
                        pRow[(x*4)+3] = pFileData8[(x*4)+3] | alphaMask;
                    }

                    pFileData8 += srcRowSizeInBytes;
                }
            } else if (bytesPerPixel == 3) {
                for (mo_int16 y = 0; y < height; ++y) {
                    mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                    for (mo_int16 x = 0; x < width; ++x) {
                        pRow[(x*4)+0] = pFileData8[(x*3)+2];
                        pRow[(x*4)+1] = pFileData8[(x*3)+1];
                        pRow[(x*4)+2] = pFileData8[(x*3)+0];
                        pRow[(x*4)+3] = 0xFF;
                    }

                    pFileData8 += srcRowSizeInBytes;
                }
            } else if (bytesPerPixel == 2) {
                for (mo_int16 y = 0; y < height; ++y) {
                    mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                    for (mo_int16 x = 0; x < width; ++x) {
                        mo_uint8 b0 = pFileData8[(x*2)+0];
                        mo_uint8 b1 = pFileData8[(x*2)+1];
                        pRow[(x*4)+0] =  (((b1 & 0x7C) >> 2)                       * 255) / 31;
                        pRow[(x*4)+1] = ((((b0 & 0xE0) >> 5) | ((b1 & 0x03) << 3)) * 255) / 31;
                        pRow[(x*4)+2] =   ((b0 & 0x1F)                             * 255) / 31;
                        pRow[(x*4)+3] =  (((b1 & 0x80) >> 7)                       * 255) | alphaMask;
                    }

                    pFileData8 += srcRowSizeInBytes;
                }
            } else {
                goto free_and_return_null;  // Unsupported format.
            }
        } break;

        case 3:     // Uncompressed black and white.
        {
            size_t srcRowSizeInBytes = width*bytesPerPixel;
            if (fileSize < srcRowSizeInBytes*height) {
                goto free_and_return_null;  // File is too small.
            }

            for (mo_int16 y = 0; y < height; ++y) {
                mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                for (mo_int16 x = 0; x < width; ++x) {
                    mo_uint8 c = pFileData8[x+0];
                    pRow[(x*4)+0] = c;
                    pRow[(x*4)+1] = c;
                    pRow[(x*4)+2] = c;
                    pRow[(x*4)+3] = 255;
                }

                pFileData8 += srcRowSizeInBytes;
            }
        } break;

        case 9:     // RLE colormapped.
        {
            if (bytesPerPixel != 1 && bytesPerPixel != 2) {
                goto free_and_return_null;
            }

            mo_int32 i = 0;
            while (i < width*height) {
                mo_uint8 rle = *pFileData8++;
                mo_uint8 count = (rle & 0x7F) + 1;
                if (rle & 0x80) {
                    mo_uint16 colorIndex = colormapOrigin;
                    if (bytesPerPixel == 1) {
                        colorIndex += pFileData8[0];
                    } else if (bytesPerPixel == 2) {
                        colorIndex += ((mo_uint16*)pFileData8)[0];
                    }

                    pFileData8 += bytesPerPixel;

                    // Grab the color from the colormap.
                    mo_uint8 r = 0;
                    mo_uint8 g = 0;
                    mo_uint8 b = 0;
                    mo_uint8 a = 255;
                    if (colormapBytesPerPixel == 4) {
                        r = pColormap8[colorIndex*4 + 2];
                        g = pColormap8[colorIndex*4 + 1];
                        b = pColormap8[colorIndex*4 + 0];
                        a = pColormap8[colorIndex*4 + 3] | alphaMask;
                    } else if (colormapBytesPerPixel == 3) {
                        r = pColormap8[colorIndex*3 + 2];
                        g = pColormap8[colorIndex*3 + 1];
                        b = pColormap8[colorIndex*3 + 0];
                    } else if (colormapBytesPerPixel == 2) {
                        mo_uint8 b0 = pColormap8[colorIndex*2 + 0];
                        mo_uint8 b1 = pColormap8[colorIndex*2 + 1];
                        r =  (((b1 & 0x7C) >> 2)                       * 255) / 31;
                        g = ((((b0 & 0xE0) >> 5) | ((b1 & 0x03) << 3)) * 255) / 31;
                        b =   ((b0 & 0x1F)                             * 255) / 31;
                        a =  (((b1 & 0x80) >> 7)                       * 255) | alphaMask;
                    }

                    for (mo_uint8 j = 0; j < count; ++j) {
                        mo_int16 y = (mo_int16)((i+j) / width);
                        mo_int16 x = (mo_int16)((i+j) - (width * y));
                        mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                        pRow[(x*4)+0] = r;
                        pRow[(x*4)+1] = g;
                        pRow[(x*4)+2] = b;
                        pRow[(x*4)+3] = a;
                    }
                } else {
                    for (mo_uint8 j = 0; j < count; ++j) {
                        mo_uint16 colorIndex = colormapOrigin;
                        if (bytesPerPixel == 1) {
                            colorIndex += pFileData8[0];
                        } else if (bytesPerPixel == 2) {
                            colorIndex += ((mo_uint16*)pFileData8)[0];
                        }

                        pFileData8 += bytesPerPixel;

                        // Grab the color from the colormap.
                        mo_uint8 r = 0;
                        mo_uint8 g = 0;
                        mo_uint8 b = 0;
                        mo_uint8 a = 255;
                        if (colormapBytesPerPixel == 4) {
                            r = pColormap8[colorIndex*4 + 2];
                            g = pColormap8[colorIndex*4 + 1];
                            b = pColormap8[colorIndex*4 + 0];
                            a = pColormap8[colorIndex*4 + 3] | alphaMask;
                        } else if (colormapBytesPerPixel == 3) {
                            r = pColormap8[colorIndex*3 + 2];
                            g = pColormap8[colorIndex*3 + 1];
                            b = pColormap8[colorIndex*3 + 0];
                        } else if (colormapBytesPerPixel == 2) {
                            mo_uint8 b0 = pColormap8[colorIndex*2 + 0];
                            mo_uint8 b1 = pColormap8[colorIndex*2 + 1];
                            r =  (((b1 & 0x7C) >> 2)                       * 255) / 31;
                            g = ((((b0 & 0xE0) >> 5) | ((b1 & 0x03) << 3)) * 255) / 31;
                            b =   ((b0 & 0x1F)                             * 255) / 31;
                            a =  (((b1 & 0x80) >> 7)                       * 255) | alphaMask;
                        }

                        mo_int16 y = (mo_int16)((i+j) / width);
                        mo_int16 x = (mo_int16)((i+j) - (width * y));
                        mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                        pRow[(x*4)+0] = r;
                        pRow[(x*4)+1] = g;
                        pRow[(x*4)+2] = b;
                        pRow[(x*4)+3] = a;
                    }
                }

                i += count;
            }
        } break;

        case 10:    // RLE RGB(A).
        {
            // RLE is a bit more annoying than uncompressed RGB so we'll do it in a slightly more inefficient way and just
            // do it all in a single loop.
            mo_int32 i = 0;
            while (i < width*height) {
                mo_uint8 rle = *pFileData8++;
                mo_uint8 count = (rle & 0x7F) + 1;
                if (rle & 0x80) {
                    mo_uint8 r = 0;
                    mo_uint8 g = 0;
                    mo_uint8 b = 0;
                    mo_uint8 a = 255;
                    if (bytesPerPixel == 4) {
                        r = pFileData8[2];
                        g = pFileData8[1];
                        b = pFileData8[0];
                        a = pFileData8[3];
                    } else if (bytesPerPixel == 3) {
                        r = pFileData8[2];
                        g = pFileData8[1];
                        b = pFileData8[0];
                    } else if (bytesPerPixel == 2) {
                        mo_uint8 b0 = pFileData8[0];
                        mo_uint8 b1 = pFileData8[1];
                        r =  (((b1 & 0x7C) >> 2)                       * 255) / 31;
                        g = ((((b0 & 0xE0) >> 5) | ((b1 & 0x03) << 3)) * 255) / 31;
                        b =   ((b0 & 0x1F)                             * 255) / 31;
                        a =  (((b1 & 0x80) >> 7)                       * 255) | alphaMask;
                    }
                    pFileData8 += bytesPerPixel;

                    for (mo_uint8 j = 0; j < count; ++j) {
                        mo_int16 y = (mo_int16)((i+j) / width);
                        mo_int16 x = (mo_int16)((i+j) - (width * y));
                        mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                        pRow[(x*4)+0] = r;
                        pRow[(x*4)+1] = g;
                        pRow[(x*4)+2] = b;
                        pRow[(x*4)+3] = a;
                    }
                } else {
                    for (mo_uint8 j = 0; j < count; ++j) {
                        mo_uint8 r = 0;
                        mo_uint8 g = 0;
                        mo_uint8 b = 0;
                        mo_uint8 a = 255;
                        if (bytesPerPixel == 4) {
                            r = pFileData8[2];
                            g = pFileData8[1];
                            b = pFileData8[0];
                            a = pFileData8[3];
                        } else if (bytesPerPixel == 3) {
                            r = pFileData8[2];
                            g = pFileData8[1];
                            b = pFileData8[0];
                        } else if (bytesPerPixel == 2) {
                            mo_uint8 b0 = pFileData8[0];
                            mo_uint8 b1 = pFileData8[1];
                            r =  (((b1 & 0x7C) >> 2)                       * 255) / 31;
                            g = ((((b0 & 0xE0) >> 5) | ((b1 & 0x03) << 3)) * 255) / 31;
                            b =   ((b0 & 0x1F)                             * 255) / 31;
                            a =  (((b1 & 0x80) >> 7)                       * 255) | alphaMask;
                        }
                        pFileData8 += bytesPerPixel;

                        mo_int16 y = (mo_int16)((i+j) / width);
                        mo_int16 x = (mo_int16)((i+j) - (width * y));
                        mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                        pRow[(x*4)+0] = r;
                        pRow[(x*4)+1] = g;
                        pRow[(x*4)+2] = b;
                        pRow[(x*4)+3] = a;
                    }
                }

                i += count;
            }
        } break;

        case 11:    // RLE compressed black and white.
        {
            if (bitsPerPixel != 8) {
                goto free_and_return_null;
            }

            mo_int32 i = 0;
            while (i < width*height) {
                mo_uint8 rle = *pFileData8++;
                mo_uint8 count = (rle & 0x7F) + 1;
                if (rle & 0x80) {
                    mo_uint8 c = pFileData8[0];
                    pFileData8 += bytesPerPixel;

                    for (mo_uint8 j = 0; j < count; ++j) {
                        mo_int16 y = (mo_int16)((i+j) / width);
                        mo_int16 x = (mo_int16)((i+j) - (width * y));
                        mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                        pRow[(x*4)+0] = c;
                        pRow[(x*4)+1] = c;
                        pRow[(x*4)+2] = c;
                        pRow[(x*4)+3] = 255;
                    }
                } else {
                    for (mo_uint8 j = 0; j < count; ++j) {
                        mo_uint8 c = pFileData8[0];
                        pFileData8 += bytesPerPixel;

                        mo_int16 y = (mo_int16)((i+j) / width);
                        mo_int16 x = (mo_int16)((i+j) - (width * y));
                        mo_uint8* pRow = (flipY) ? (pImageData + (y*width*4)) : (pImageData + ((height-y-1)*width*4));
                        pRow[(x*4)+0] = c;
                        pRow[(x*4)+1] = c;
                        pRow[(x*4)+2] = c;
                        pRow[(x*4)+3] = 255;
                    }
                }

                i += count;
            }
        } break;
    }



    if (pWidthOut  != NULL) *pWidthOut  = (unsigned int)width;
    if (pHeightOut != NULL) *pHeightOut = (unsigned int)height;
    if (pFormat    != NULL) *pFormat    = mo_image_format_rgba8;
    return (void*)pImageData;

free_and_return_null:
    mo_free(pImageData);
    return NULL;
}

#ifdef MO_HAS_STB_IMAGE
static void* mo_image_load__stb(const void* pFileData, size_t fileSize, unsigned int* pWidthOut, unsigned int* pHeightOut, mo_image_format* pFormat)
{
    if (pWidthOut  != NULL) *pWidthOut  = 0;
    if (pHeightOut != NULL) *pHeightOut = 0;
    if (pFormat    != NULL) *pFormat    = mo_image_format_unknown;
    if (pFileData  == NULL) return NULL;

    int widthSTB;
    int heightSTB;
    stbi_uc* pImageData = stbi_load_from_memory((const stbi_uc*)pFileData, (int)fileSize, &widthSTB, &heightSTB, NULL, 4);
    if (pImageData == NULL) {
        return NULL;
    }

    if (pWidthOut  != NULL) *pWidthOut  = (unsigned int)widthSTB;
    if (pHeightOut != NULL) *pHeightOut = (unsigned int)heightSTB;
    if (pFormat    != NULL) *pFormat    = mo_image_format_rgba8;
    return (void*)pImageData;
}
#endif

#ifdef MO_HAS_DR_PCX
static void* mo_image_load__pcx(const void* pFileData, size_t fileSize, unsigned int* pWidthOut, unsigned int* pHeightOut, mo_image_format* pFormat)
{
    if (pWidthOut  != NULL) *pWidthOut  = 0;
    if (pHeightOut != NULL) *pHeightOut = 0;
    if (pFormat    != NULL) *pFormat    = mo_image_format_unknown;
    if (pFileData  == NULL) return NULL;

    int widthSTB;
    int heightSTB;
    dr_uint8* pImageData = drpcx_load_memory(pFileData, (int)fileSize, DR_FALSE, &widthSTB, &heightSTB, NULL, 4);
    if (pImageData == NULL) {
        return NULL;
    }

    if (pWidthOut  != NULL) *pWidthOut  = (unsigned int)widthSTB;
    if (pHeightOut != NULL) *pHeightOut = (unsigned int)heightSTB;
    if (pFormat    != NULL) *pFormat    = mo_image_format_rgba8;
    return (void*)pImageData;
}
#endif

mo_result mo_image_load(mo_context* pContext, const char* filePath, mo_image** ppImage)
{
    if (ppImage == NULL) return MO_INVALID_ARGS;
    mo_zero_object(ppImage);

    if (pContext == NULL || filePath == NULL) return MO_INVALID_ARGS;

    size_t fileSize;
    void* pFileData = mo_open_and_read_file(pContext, filePath, &fileSize);
    if (pFileData == NULL) {
        return MO_DOES_NOT_EXIST;
    }

    unsigned int width = 0;
    unsigned int height = 0;
    mo_image_format format = mo_image_format_unknown;
    const void* pImageData = NULL;
    void* pImageDataTGA = NULL;
#ifdef MO_HAS_STB_IMAGE
    void* pImageDataSTB = NULL;
#endif
#ifdef MO_HAS_DR_PCX
    void* pImageDataPCX = NULL;
#endif

    if (mo_extension_equal(filePath, "moimage")) {
        pImageData = mo_image_load__native(pFileData, fileSize, &width, &height, &format);
        if (pImageData == NULL) {
            mo_logf(pContext, "Corrupt image file (%s)", filePath);
            mo_free(pFileData);
            return MO_INVALID_RESOURCE;
        }
    } else if (mo_extension_equal(filePath, "tga")) {
        pImageDataTGA = mo_image_load__tga(pFileData, fileSize, &width, &height, &format);
        if (pImageDataTGA == NULL) {
            mo_logf(pContext, "Corrupt image file (%s)", filePath);
            mo_free(pFileData);
            return MO_INVALID_RESOURCE;
        }

        pImageData = pImageDataTGA;
    } else {
#ifdef MO_HAS_DR_PCX
        if (pImageData == NULL && mo_extension_equal(filePath, "pcx")) {
            pImageDataPCX = mo_image_load__pcx(pFileData, fileSize, &width, &height, &format);
            if (pImageDataPCX != NULL) {
                pImageData = pImageDataPCX;
            }
        }
#endif
#ifdef MO_HAS_STB_IMAGE
        if (pImageData == NULL) {
            pImageDataSTB = mo_image_load__stb(pFileData, fileSize, &width, &height, &format);
            if (pImageDataSTB == NULL) {
                mo_logf(pContext, "Unsupported or corrupt image file (%s): %s", filePath, stbi__g_failure_reason);
                mo_free(pFileData);
                return MO_INVALID_RESOURCE;
            }

            pImageData = pImageDataSTB;
        }
#endif

        if (pImageData == NULL) {
            return MO_INVALID_RESOURCE;
        }
    }

    mo_result result = mo_image_create(pContext, width, height, format, pImageData, ppImage);

    if (pImageDataTGA) {
        mo_free(pImageDataTGA);
    }

#ifdef MO_HAS_STB_IMAGE
    if (pImageDataSTB) {
        stbi_image_free(pImageDataSTB);
    }
#endif
#ifdef MO_HAS_DR_PCX
    if (pImageDataPCX) {
        drpcx_free(pImageDataPCX);
    }
#endif

    mo_free(pFileData); // <-- This must be done last! The reason is that pImageData might just be an offset of this pointer.
    return result;
}

void mo_image_delete(mo_context* pContext, mo_image* pImage)
{
    if (pContext == NULL || pImage == NULL) return;
    mo_free(pImage);
}


//// Drawing ////

static float mo_color_distance2(mo_color_rgba c1, mo_color_rgba c2)
{
    // This is just simple Euclidean distance. Can probably improve the accuracy of this later on.
    int diffr = (int)c2.r - (int)c1.r;
    int diffg = (int)c2.g - (int)c1.g;
    int diffb = (int)c2.b - (int)c1.b;
    return (float)(diffr*diffr + diffg*diffg + diffb*diffb);
}

mo_color_index mo_find_closest_color(mo_context* pContext, mo_color_rgba color)
{
    if (pContext == NULL) return 0;

    // We just do a simple distance test.
    float minDistance = 3.402823e+38f;  // FLT_MAX
    mo_color_index closestIndex = 0;

    mo_color_index i = 0;
    for (;;) {
        if (i != pContext->profile.transparentColorIndex) {
            float distance = mo_color_distance2(color, pContext->profile.palette[i]);
            if (minDistance > distance) {
                minDistance = distance;
                closestIndex = i;

                if (minDistance == 0) {
                    break;
                }
            }
        }

        mo_assert(pContext->profile.paletteSize > 0);
        if (i == 255 || i == pContext->profile.paletteSize-1) {
            break;
        }

        i += 1;
    }

    return closestIndex;
}

void mo_clear(mo_context* pContext, mo_color_index colorIndex)
{
    if (pContext == NULL) return;

    for (unsigned int y = 0; y < pContext->profile.resolutionY; ++y) {
        for (unsigned int x = 0; x < pContext->profile.resolutionX; ++x) {
            pContext->screen[y*pContext->profile.resolutionX + x] = colorIndex;
        }
    }
}

void mo_draw_quad(mo_context* pContext, int posX, int posY, int sizeX, int sizeY, mo_color_index colorIndex)
{
    if (pContext == NULL) return;

    int left   = posX;
    int top    = posY;
    int right  = left + sizeX;
    int bottom = top + sizeY;

    // Is the quad entirely out of bounds?
    if (right < 0 || bottom < 0) return;
    if (left >= (int)pContext->profile.resolutionX || top >= (int)pContext->profile.resolutionY) return;

    // Clamp.
    if (left   < 0)   left   = 0;
    if (top    < 0)   top    = 0;
    if (right  > (int)pContext->profile.resolutionX) right  = (int)pContext->profile.resolutionX;
    if (bottom > (int)pContext->profile.resolutionY) bottom = (int)pContext->profile.resolutionY;

    // Draw.
    // TODO: Optimize me.
    for (int y = top; y < bottom; ++y) {
        for (int x = left; x < right; ++x) {
            pContext->screen[y*pContext->profile.resolutionX + x] = colorIndex;
        }
    }
}

static mo_uint8 pFontData[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff,
    0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff,
    0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
    0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
    0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static void mo_draw_glyph(mo_context* pContext, int posX, int posY, char c, mo_color_index colorIndex)
{
    c -= 16;
    if (c < 0 || c > 111) c = 0;

    const unsigned int glyphSizeX = 9;
    const unsigned int glyphSizeY = 9;
    unsigned int offset = (c * (glyphSizeX*glyphSizeY));

    int left   = posX;
    int top    = posY;
    int right  = left + glyphSizeX;
    int bottom = top + glyphSizeY;

    int imageXOffset = 0;
    int imageYOffset = 0;

    // Is the quad entirely out of bounds?
    if (right < 0 || bottom < 0) return;
    if (left >= (int)pContext->profile.resolutionX || top >= (int)pContext->profile.resolutionY) return;

    // Clamp.
    if (left < 0) {
        imageXOffset = -left;
        left = 0;
    }
    if (top < 0) {
        imageYOffset = -top;
        top = 0;
    }

    if (right  > (int)pContext->profile.resolutionX) right  = (int)pContext->profile.resolutionX;
    if (bottom > (int)pContext->profile.resolutionY) bottom = (int)pContext->profile.resolutionY;

    // Draw.
    // TODO: Optimize me.
    for (int y = top; y < bottom; ++y) {
        for (int x = left; x < right; ++x) {
            int glyphX = imageXOffset + (x - left);
            int glyphY = imageYOffset + (y - top);
            mo_uint8 fontPixel = (pFontData + offset)[glyphY*glyphSizeX + glyphX];
            if (fontPixel != 0x00) {
                pContext->screen[y*pContext->profile.resolutionX + x] = colorIndex;
            }
        }
    }
}

void mo_draw_text(mo_context* pContext, int posX, int posY, mo_color_index colorIndex, const char* text)
{
    if (pContext == NULL) return;

    int penPosX = posX;
    int penPosY = posY;
    while (*text != '\0') {
        mo_draw_glyph(pContext, penPosX, penPosY, *text, colorIndex);

        penPosX += 9;
        text += 1;
    }
}

void mo_draw_textf(mo_context* pContext, int posX, int posY, mo_color_index colorIndex, const char* format, ...)
{
    va_list args;

    va_start(args, format);
#if defined(_MSC_VER)
    int len = _vscprintf(format, args);
#else
    int len = vsnprintf(NULL, 0, format, args);
#endif
    va_end(args);

    if (len < 0) {
        return;
    }

    char* text = (char*)mo_malloc(len+1);
    if (text == NULL) {
        va_end(args);
        return;
    }

    va_start(args, format);
#if defined(_MSC_VER)
    len = vsprintf_s(text, len+1, format, args);
#else
    len = vsnprintf(text, len+1, format, args);
#endif
    va_end(args);

    mo_draw_text(pContext, posX, posY, colorIndex, text);

    mo_free(text);
    va_end(args);
}

void mo_draw_image(mo_context* pContext, int dstX, int dstY, mo_image* pImage, int srcX, int srcY, int srcWidth, int srcHeight)
{
    if (pImage == NULL) return;
    mo_draw_image_scaled(pContext, dstX, dstY, pImage->width, pImage->height, pImage, srcX, srcY, srcWidth, srcHeight);
}

void mo_draw_image_scaled(mo_context* pContext, int dstX, int dstY, int dstWidth, int dstHeight, mo_image* pImage, int srcX, int srcY, int srcWidth, int srcHeight/*, float rotation*/)
{
    if (pContext == NULL || pImage == NULL) return;
    //mo_draw_quad(pContext, x, y, pImage->width, pImage->height, 3);   // Debugging

    //mo_assert(rotation == 0);   // Rotation isn't supported yet.

#if 1
    // If you trigger any of these asserts it means you have an error in your sub-imaging logic.
    mo_assert(srcWidth  > 0);
    mo_assert(srcHeight > 0);
    mo_assert(srcX >= 0);
    mo_assert(srcY >= 0);
    mo_assert(srcX+srcWidth  <= (int)pImage->width);
    mo_assert(srcY+srcHeight <= (int)pImage->height);
#endif

#if 0
    // Make sure inputs are clamped.
    if (srcX < 0) {
        srcWidth += srcX;
        srcX = 0;
    }
    if (srcY < 0) {
        srcHeight += srcY;
        srcY = 0;
    }

    if (srcWidth+srcX > (int)pImage->width) {
        srcWidth = pImage->width - srcX;
    }
    if (srcHeight+srcY > (int)pImage->height) {
        srcHeight = pImage->height - srcY;
    }
#endif

    float scaleX = (float)srcWidth / dstWidth;
    float scaleY = (float)srcHeight / dstHeight;

    // Is the quad entirely out of bounds?
    if (dstX+dstWidth < 0 || dstY+dstHeight < 0) return;
    if (dstX >= (int)pContext->profile.resolutionX || dstY >= (int)pContext->profile.resolutionY) return;

    // Clamp.
    float srcXOffset = 0;
    float srcYOffset = 0;
    if (dstX < 0) {
        srcXOffset = -dstX*scaleX;
        dstWidth += dstX;
        dstX = 0;
    }
    if (dstY < 0) {
        srcYOffset = -dstY*scaleY;
        dstHeight += dstY;
        dstY = 0;
    }

    if (dstWidth+dstX > (int)pContext->profile.resolutionX) {
        dstWidth = (int)pContext->profile.resolutionX - dstX;
    }
    if (dstHeight+dstY > (int)pContext->profile.resolutionY) {
        dstHeight = (int)pContext->profile.resolutionY - dstY;
    }

    //if (rotation == 0) {
        if (scaleX == 1.0f && scaleY == 1.0f) {
            // No rotation, no scaling. Fast path.
            // TODO: Optimize me.
            for (int y = 0; y < dstHeight; ++y) {
                for (int x = 0; x < dstWidth; ++x) {
                    int imageX = (int)(srcXOffset + srcX + x);
                    int imageY = (int)(srcYOffset + srcY + y);

                    mo_color_index colorIndex = pImage->pData[imageY*pImage->width + imageX];
                    if (colorIndex != pContext->profile.transparentColorIndex) {
                        pContext->screen[(dstY+y)*pContext->profile.resolutionX + (dstX+x)] = colorIndex;
                    }
                }
            }
        } else {
            // No rotation, with scaling.
            // TODO: Optimize me.
            for (int y = 0; y < dstHeight; ++y) {
                for (int x = 0; x < dstWidth; ++x) {
                    int imageX = (int)(srcXOffset + srcX + (x * scaleX));
                    int imageY = (int)(srcYOffset + srcY + (y * scaleY));

                    mo_color_index colorIndex = pImage->pData[imageY*pImage->width + imageX];
                    if (colorIndex != pContext->profile.transparentColorIndex) {
                        pContext->screen[(dstY+y)*pContext->profile.resolutionX + (dstX+x)] = colorIndex;
                    }
                }
            }
        }
    //} else {
        // It's rotated. We do rotation and scaling on the same path for now.

    //}
}


//// Audio ////

mo_result mo_sound_source_create__generic_decoder(mo_context* pContext, mo_sound_source_type type, size_t dataSize, const void* pData, mo_sound_source** ppSource)
{
    if (ppSource == NULL) return MO_INVALID_ARGS;
    mo_zero_object(ppSource);

    if (pContext == NULL || dataSize == 0 || pData == NULL) return MO_INVALID_ARGS;

    mo_sound_source* pSource = (mo_sound_source*)mo_calloc(sizeof(*pSource) + dataSize);
    if (pSource == NULL) {
        return MO_OUT_OF_MEMORY;
    }

    pSource->type = type;
    pSource->vorbis.dataSize = dataSize;
    mo_copy_memory(pSource->vorbis.pData, pData, dataSize);

    *ppSource = pSource;
    return MO_SUCCESS;
}

mo_result mo_sound_source_create_vorbis(mo_context* pContext, size_t dataSize, const void* pData, mo_sound_source** ppSource)
{
#ifdef MO_HAS_STB_VORBIS
    return mo_sound_source_create__generic_decoder(pContext, mo_sound_source_type_vorbis, dataSize, pData, ppSource);
#else
    (void)pContext;
    (void)dataSize;
    (void)pData;
    (void)ppSource;
    return MO_UNSUPPORTED_AUDIO_FORMAT;
#endif
}

mo_result mo_sound_source_create_flac(mo_context* pContext, size_t dataSize, const void* pData, mo_sound_source** ppSource)
{
#ifdef MO_HAS_STB_VORBIS
    return mo_sound_source_create__generic_decoder(pContext, mo_sound_source_type_flac, dataSize, pData, ppSource);
#else
    (void)pContext;
    (void)dataSize;
    (void)pData;
    (void)ppSource;
    return MO_UNSUPPORTED_AUDIO_FORMAT;
#endif
}

mo_result mo_sound_source_create(mo_context* pContext, unsigned int channels, unsigned int sampleRate, mo_uint64 sampleCount, const mo_int16* pSampleData, mo_sound_source** ppSource)
{
    if (ppSource == NULL) return MO_INVALID_ARGS;
    mo_zero_object(ppSource);

    if (pContext == NULL || channels == 0 || sampleRate == 0 || sampleCount == 0) return MO_INVALID_ARGS;
    if (sampleCount > SIZE_MAX/sizeof(mo_int16)) return MO_INVALID_ARGS; // Sound is too big.

    size_t sampleDataSize = (size_t)(sampleCount * sizeof(mo_int16));

    mo_sound_source* pSource = (mo_sound_source*)mo_calloc(sizeof(*pSource) + sampleDataSize);
    if (pSource == NULL) {
        return MO_OUT_OF_MEMORY;
    }

    pSource->type = mo_sound_source_type_raw;
    pSource->raw.channels = channels;
    pSource->raw.sampleRate = sampleRate;
    pSource->raw.sampleCount = sampleCount;
    mo_copy_memory(pSource->raw.pSampleData, pSampleData, sampleDataSize);

    *ppSource = pSource;
    return MO_SUCCESS;
}

static mo_int16* mo_sound_source_load__wav(const void* pFileData, size_t fileSize, unsigned int* pChannels, unsigned int* pSampleRate, mo_uint64* pSampleCount)
{
    // NOTES:
    // - This function only works on little endian.
    // - This should work seamlessly with Wave64.

    const mo_uint8* pFileData8 = (const mo_uint8*)pFileData;

    // These are #undef-ed at the end of this function.
    #define MO_WAV_MALLOC(sz)           mo_malloc(sz)   //malloc(sz)
    #define MO_WAV_FREE(p)              mo_free(p)      //free(p)
    #define MO_WAV_COPY(dst, src, sz)   mo_copy_memory(dst, src, sz) //do { for (size_t i = 0; i < (sz); ++i) { ((unsigned char*)(dst))[i] = ((unsigned char*)(src))[i]; } } while (0)
    #define MO_WAV_SEEK(offset)         (pFileData8 += (offset), fileSize -= (size_t)(offset))
    #define MO_WAV_READ_UINT8()         (*(unsigned char*     )(pFileData8)); MO_WAV_SEEK(1)
    #define MO_WAV_READ_UINT16()        (*(unsigned short*    )(pFileData8)); MO_WAV_SEEK(2)
    #define MO_WAV_READ_UINT32()        (*(unsigned int*      )(pFileData8)); MO_WAV_SEEK(4)
    #define MO_WAV_READ_UINT64()        (*(unsigned long long*)(pFileData8)); MO_WAV_SEEK(8)
    #define MO_WAV_READ_GUID(guid)      MO_WAV_COPY(guid, pFileData8, 16); MO_WAV_SEEK(16)
    #define MO_WAV_GUID_EQUAL(a, b)     ((mo_bool32)(((((mo_uint64*)(a))[0] == ((mo_uint64*)(b))[0]) && (((mo_uint64*)(a))[1] == ((mo_uint64*)(b))[1]))))

    const unsigned char wavGUID_W64_RIFF[16] = {0x72,0x69,0x66,0x66, 0x2E,0x91, 0xCF,0x11, 0xA5,0xD6, 0x28,0xDB,0x04,0xC1,0x00,0x00};    // 66666972-912E-11CF-A5D6-28DB04C10000
    const unsigned char wavGUID_W64_WAVE[16] = {0x77,0x61,0x76,0x65, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    // 65766177-ACF3-11D3-8CD1-00C04F8EDB8A
    const unsigned char wavGUID_W64_FMT [16] = {0x66,0x6D,0x74,0x20, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    // 20746D66-ACF3-11D3-8CD1-00C04F8EDB8A
    const unsigned char wavGUID_W64_DATA[16] = {0x64,0x61,0x74,0x61, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};

    if (pChannels) *pChannels = 0;
    if (pSampleRate) *pSampleRate = 0;
    if (pSampleCount) *pSampleCount = 0;
    if (pFileData == NULL || fileSize < 4) return NULL;

    mo_bool32 isWave64 = MO_FALSE;

    mo_uint32 riffFOURCC = MO_WAV_READ_UINT32();
    if (riffFOURCC == 0x46464952) {
        isWave64 = MO_FALSE;
    } else if (riffFOURCC == 0x66666972) {
        isWave64 = MO_TRUE;
        if (fileSize < 12) return NULL;
        for (int i = 0; i < 12; ++i) { if (pFileData8[i] != wavGUID_W64_RIFF[i+4]) return NULL; }
        MO_WAV_SEEK(12);
    } else {
        return NULL;
    }

    if (!isWave64) {
        if (fileSize < 8) return NULL;
        mo_uint32 chunkSize  = MO_WAV_READ_UINT32();
        mo_uint32 waveFOURCC = MO_WAV_READ_UINT32();
        if (chunkSize < 36 || waveFOURCC != 0x45564157) {
            return NULL;
        }
    } else {
        if (fileSize < 24) return NULL;
        mo_uint64 chunkSize = MO_WAV_READ_UINT64();
        if (chunkSize < 84) {
            return NULL;
        }

        mo_uint8 waveGUID[16];
        MO_WAV_READ_GUID(waveGUID);
        if (!MO_WAV_GUID_EQUAL(waveGUID, wavGUID_W64_WAVE)) {
            return NULL;
        }
    }


    // Next chunk should always be the "fmt " chunk.
    mo_uint64 fmtSize = 0;
    mo_uint32 fmtPadding = 0;
    if (!isWave64) {
        if (fileSize < 8) return NULL;

        mo_uint32 fmtFOURCC = MO_WAV_READ_UINT32();
        fmtSize = MO_WAV_READ_UINT32();
        fmtPadding = fmtSize % 2;

        if (fmtFOURCC != 0x20746d66) {
            return NULL;
        }
    } else {
        if (fileSize < 24) return NULL;

        mo_uint8 fmtGUID[16];
        MO_WAV_READ_GUID(fmtGUID);
        if (!MO_WAV_GUID_EQUAL(fmtGUID, wavGUID_W64_FMT)) {
            return NULL;
        }

        fmtSize  = MO_WAV_READ_UINT64();
        fmtSize -= 24;  // Subtract 24 because w64 includes the size of the header which is inconsistent with regular WAV.
        fmtPadding = fmtSize % 8;
    }

    if (fileSize < 16) return NULL;

    mo_uint16 formatTag      = MO_WAV_READ_UINT16();
    mo_uint16 channels       = MO_WAV_READ_UINT16();
    mo_uint32 sampleRate     = MO_WAV_READ_UINT32();
    mo_uint32 avgBytesPerSec = MO_WAV_READ_UINT32(); (void)avgBytesPerSec;
    mo_uint16 blockAlign     = MO_WAV_READ_UINT16();
    mo_uint16 bitsPerSample  = MO_WAV_READ_UINT16();

    mo_uint16 extendedSize = 0;
    mo_uint16 validBitsPerSample = 0;
    mo_uint32 channelMask = 0;
    mo_uint8  subformatGUID[16] = {0};
    if (fmtSize > 16) {
        if (fileSize < fmtSize-16) return NULL;
        extendedSize = MO_WAV_READ_UINT16();

        size_t leftover = 0;
        if (extendedSize > 0) {
            if (extendedSize != 22 || fileSize < 22) return NULL; // The extended size should always be 22.
            validBitsPerSample = MO_WAV_READ_UINT16();
            channelMask        = MO_WAV_READ_UINT32();
            MO_WAV_READ_GUID(subformatGUID);
            leftover = (size_t)(fmtSize - 40);
        } else {
            leftover = (size_t)(fmtSize - 18);
        }

        if (fileSize < leftover) return NULL;
        pFileData8 += leftover; fileSize -= leftover;
    }

    if (fileSize < fmtPadding) return NULL;
    pFileData8 += fmtPadding; fileSize -= fmtPadding;

    // The only other chunk we care about now is the "data" chunk. This is not necessarily the next chunk so we need to loop.
    mo_uint64 dataSize;
    mo_uint32 dataPadding;
    for (;;) {
        dataSize = 0;
        dataPadding = 0;
        if (!isWave64) {
            if (fileSize < 8) return NULL;

            mo_uint32 dataFOURCC = MO_WAV_READ_UINT32();
            dataSize = MO_WAV_READ_UINT32();
            dataPadding = dataSize % 2;

            if (dataFOURCC == 0x61746164) {
                break;
            }
        } else {
            if (fileSize < 24) return NULL;

            mo_uint8 dataGUID[16];
            MO_WAV_READ_GUID(dataGUID);

            mo_bool32 isDataChunk = MO_WAV_GUID_EQUAL(dataGUID, wavGUID_W64_DATA);
            dataSize  = MO_WAV_READ_UINT64();
            dataSize -= 24;    // Subtract 24 because w64 includes the size of the header which is inconsistent with regular WAV.
            dataPadding = dataSize % 8;

            if (isDataChunk) {
                break;  // It's the "data" GUID.
            }
        }

        dataSize += dataPadding;
        if (fileSize < dataSize) return NULL;
        MO_WAV_SEEK(dataSize);
    }

    // At this point we should be sitting on the raw sample data.
    mo_uint64 sampleCount = dataSize / (blockAlign / channels);
    if (sampleCount > 0x7FFFFFFF) {
        return NULL;    // File is too big.
    }

    mo_uint16 actualFormatTag = formatTag;
    if (actualFormatTag == 0xFFFE) {
        actualFormatTag = *(mo_uint16*)subformatGUID;   // The actual format tag is derived from the first 2 bytes of the subformat GUID.
    }

    mo_int16* pSamples = (mo_int16*)MO_WAV_MALLOC((size_t)sampleCount * sizeof(mo_int16));
    if (pSamples == NULL) {
        return NULL;
    }

    switch (actualFormatTag)
    {
        case 0x0001:    // WAVE_FORMAT_PCM
        {
            if (bitsPerSample == 16) {
                MO_WAV_COPY(pSamples, pFileData8, (size_t)sampleCount * sizeof(mo_int16));
            } else {
                // 8-, 24- and 32-bit conversions can be optimized.
                if (bitsPerSample == 8) {
                    if (fileSize < sampleCount*1) goto free_and_return_null;
                    for (mo_uint64 i = 0; i < sampleCount; ++i) {
                        pSamples[i] = ((mo_int16)pFileData8[i] - 128) << 8;
                    }
                    pFileData8 += sampleCount*1; fileSize -= (size_t)sampleCount*1;
                } else if (bitsPerSample == 24) {
                    if (fileSize < sampleCount*3) goto free_and_return_null;
                    for (mo_uint64 i = 0; i < sampleCount; ++i) {
                        mo_uint32 s0 = pFileData8[i*3 + 0];
                        mo_uint32 s1 = pFileData8[i*3 + 1];
                        mo_uint32 s2 = pFileData8[i*3 + 2];
                        int32_t sample32 = (int32_t)((s0 << 8) | (s1 << 16) | (s2 << 24));
                        pSamples[i] = sample32 >> 16;
                    }
                    pFileData8 += sampleCount*3; fileSize -= (size_t)sampleCount*3;
                } else if (bitsPerSample == 32) {
                    if (fileSize < sampleCount*4) goto free_and_return_null;
                    for (mo_uint64 i = 0; i < sampleCount; ++i) {
                        pSamples[i] = ((mo_uint32*)pFileData8)[i] >> 16;
                    }
                    pFileData8 += sampleCount*4; fileSize -= (size_t)sampleCount*4;
                } else {
                    // Generic.
                    mo_uint32 bytesPerSample = (mo_uint32)(blockAlign / channels);
                    for (mo_uint64 i = 0; i < sampleCount; ++i) {
                        if (fileSize < bytesPerSample) goto free_and_return_null;

                        mo_int32 sample32 = 0;
                        mo_int32 shift = (8 - bytesPerSample) * 8;
                        for (mo_uint16 j = 0; j < bytesPerSample && j < 4; ++j) {
                            sample32 |= (mo_uint32)(pFileData8[j]) << shift;
                            shift += 8;
                        }

                        pSamples[i] = sample32 >> 16;
                        pFileData8 += bytesPerSample; fileSize -= bytesPerSample;
                    }
                }
            }
        } break;

        case 0x0003:    // WAVE_FORMAT_IEEE_FLOAT
        {
            if (bitsPerSample == 32) {
                for (mo_uint64 i = 0; i < sampleCount; ++i) {
                    if (fileSize < 4) goto free_and_return_null;
                    pSamples[i] = (mo_int16)((*(float*)pFileData8) * 32768.0f);
                    pFileData8 += 4; fileSize -= 4;
                }
            } else if (bitsPerSample == 64) {
                for (mo_uint64 i = 0; i < sampleCount; ++i) {
                    if (fileSize < 8) goto free_and_return_null;
                    pSamples[i] = (mo_int16)((*(double*)pFileData8) * 32768.0);
                    pFileData8 += 8; fileSize -= 8;
                }
            } else {
                goto free_and_return_null;
            }
        } break;

        case 0x0006:    // WAVE_FORMAT_ALAW
        {
            mo_uint16 table[256] = {
                0xEA80, 0xEB80, 0xE880, 0xE980, 0xEE80, 0xEF80, 0xEC80, 0xED80, 0xE280, 0xE380, 0xE080, 0xE180, 0xE680, 0xE780, 0xE480, 0xE580,
                0xF540, 0xF5C0, 0xF440, 0xF4C0, 0xF740, 0xF7C0, 0xF640, 0xF6C0, 0xF140, 0xF1C0, 0xF040, 0xF0C0, 0xF340, 0xF3C0, 0xF240, 0xF2C0,
                0xAA00, 0xAE00, 0xA200, 0xA600, 0xBA00, 0xBE00, 0xB200, 0xB600, 0x8A00, 0x8E00, 0x8200, 0x8600, 0x9A00, 0x9E00, 0x9200, 0x9600,
                0xD500, 0xD700, 0xD100, 0xD300, 0xDD00, 0xDF00, 0xD900, 0xDB00, 0xC500, 0xC700, 0xC100, 0xC300, 0xCD00, 0xCF00, 0xC900, 0xCB00,
                0xFEA8, 0xFEB8, 0xFE88, 0xFE98, 0xFEE8, 0xFEF8, 0xFEC8, 0xFED8, 0xFE28, 0xFE38, 0xFE08, 0xFE18, 0xFE68, 0xFE78, 0xFE48, 0xFE58,
                0xFFA8, 0xFFB8, 0xFF88, 0xFF98, 0xFFE8, 0xFFF8, 0xFFC8, 0xFFD8, 0xFF28, 0xFF38, 0xFF08, 0xFF18, 0xFF68, 0xFF78, 0xFF48, 0xFF58,
                0xFAA0, 0xFAE0, 0xFA20, 0xFA60, 0xFBA0, 0xFBE0, 0xFB20, 0xFB60, 0xF8A0, 0xF8E0, 0xF820, 0xF860, 0xF9A0, 0xF9E0, 0xF920, 0xF960,
                0xFD50, 0xFD70, 0xFD10, 0xFD30, 0xFDD0, 0xFDF0, 0xFD90, 0xFDB0, 0xFC50, 0xFC70, 0xFC10, 0xFC30, 0xFCD0, 0xFCF0, 0xFC90, 0xFCB0,
                0x1580, 0x1480, 0x1780, 0x1680, 0x1180, 0x1080, 0x1380, 0x1280, 0x1D80, 0x1C80, 0x1F80, 0x1E80, 0x1980, 0x1880, 0x1B80, 0x1A80,
                0x0AC0, 0x0A40, 0x0BC0, 0x0B40, 0x08C0, 0x0840, 0x09C0, 0x0940, 0x0EC0, 0x0E40, 0x0FC0, 0x0F40, 0x0CC0, 0x0C40, 0x0DC0, 0x0D40,
                0x5600, 0x5200, 0x5E00, 0x5A00, 0x4600, 0x4200, 0x4E00, 0x4A00, 0x7600, 0x7200, 0x7E00, 0x7A00, 0x6600, 0x6200, 0x6E00, 0x6A00,
                0x2B00, 0x2900, 0x2F00, 0x2D00, 0x2300, 0x2100, 0x2700, 0x2500, 0x3B00, 0x3900, 0x3F00, 0x3D00, 0x3300, 0x3100, 0x3700, 0x3500,
                0x0158, 0x0148, 0x0178, 0x0168, 0x0118, 0x0108, 0x0138, 0x0128, 0x01D8, 0x01C8, 0x01F8, 0x01E8, 0x0198, 0x0188, 0x01B8, 0x01A8,
                0x0058, 0x0048, 0x0078, 0x0068, 0x0018, 0x0008, 0x0038, 0x0028, 0x00D8, 0x00C8, 0x00F8, 0x00E8, 0x0098, 0x0088, 0x00B8, 0x00A8,
                0x0560, 0x0520, 0x05E0, 0x05A0, 0x0460, 0x0420, 0x04E0, 0x04A0, 0x0760, 0x0720, 0x07E0, 0x07A0, 0x0660, 0x0620, 0x06E0, 0x06A0,
                0x02B0, 0x0290, 0x02F0, 0x02D0, 0x0230, 0x0210, 0x0270, 0x0250, 0x03B0, 0x0390, 0x03F0, 0x03D0, 0x0330, 0x0310, 0x0370, 0x0350
            };

            if (fileSize < sampleCount*1) goto free_and_return_null;
            for (mo_uint64 i = 0; i < sampleCount; ++i) {
                pSamples[i] = table[pFileData8[i]];
            }
            pFileData8 += sampleCount*1; fileSize -= (size_t)sampleCount*1;
        } break;

        case 0x0007:    // WAVE_FORMAT_MULAW
        {
            mo_uint16 table[256] = {
                0x8284, 0x8684, 0x8A84, 0x8E84, 0x9284, 0x9684, 0x9A84, 0x9E84, 0xA284, 0xA684, 0xAA84, 0xAE84, 0xB284, 0xB684, 0xBA84, 0xBE84,
                0xC184, 0xC384, 0xC584, 0xC784, 0xC984, 0xCB84, 0xCD84, 0xCF84, 0xD184, 0xD384, 0xD584, 0xD784, 0xD984, 0xDB84, 0xDD84, 0xDF84,
                0xE104, 0xE204, 0xE304, 0xE404, 0xE504, 0xE604, 0xE704, 0xE804, 0xE904, 0xEA04, 0xEB04, 0xEC04, 0xED04, 0xEE04, 0xEF04, 0xF004,
                0xF0C4, 0xF144, 0xF1C4, 0xF244, 0xF2C4, 0xF344, 0xF3C4, 0xF444, 0xF4C4, 0xF544, 0xF5C4, 0xF644, 0xF6C4, 0xF744, 0xF7C4, 0xF844,
                0xF8A4, 0xF8E4, 0xF924, 0xF964, 0xF9A4, 0xF9E4, 0xFA24, 0xFA64, 0xFAA4, 0xFAE4, 0xFB24, 0xFB64, 0xFBA4, 0xFBE4, 0xFC24, 0xFC64,
                0xFC94, 0xFCB4, 0xFCD4, 0xFCF4, 0xFD14, 0xFD34, 0xFD54, 0xFD74, 0xFD94, 0xFDB4, 0xFDD4, 0xFDF4, 0xFE14, 0xFE34, 0xFE54, 0xFE74,
                0xFE8C, 0xFE9C, 0xFEAC, 0xFEBC, 0xFECC, 0xFEDC, 0xFEEC, 0xFEFC, 0xFF0C, 0xFF1C, 0xFF2C, 0xFF3C, 0xFF4C, 0xFF5C, 0xFF6C, 0xFF7C,
                0xFF88, 0xFF90, 0xFF98, 0xFFA0, 0xFFA8, 0xFFB0, 0xFFB8, 0xFFC0, 0xFFC8, 0xFFD0, 0xFFD8, 0xFFE0, 0xFFE8, 0xFFF0, 0xFFF8, 0x0000,
                0x7D7C, 0x797C, 0x757C, 0x717C, 0x6D7C, 0x697C, 0x657C, 0x617C, 0x5D7C, 0x597C, 0x557C, 0x517C, 0x4D7C, 0x497C, 0x457C, 0x417C,
                0x3E7C, 0x3C7C, 0x3A7C, 0x387C, 0x367C, 0x347C, 0x327C, 0x307C, 0x2E7C, 0x2C7C, 0x2A7C, 0x287C, 0x267C, 0x247C, 0x227C, 0x207C,
                0x1EFC, 0x1DFC, 0x1CFC, 0x1BFC, 0x1AFC, 0x19FC, 0x18FC, 0x17FC, 0x16FC, 0x15FC, 0x14FC, 0x13FC, 0x12FC, 0x11FC, 0x10FC, 0x0FFC,
                0x0F3C, 0x0EBC, 0x0E3C, 0x0DBC, 0x0D3C, 0x0CBC, 0x0C3C, 0x0BBC, 0x0B3C, 0x0ABC, 0x0A3C, 0x09BC, 0x093C, 0x08BC, 0x083C, 0x07BC,
                0x075C, 0x071C, 0x06DC, 0x069C, 0x065C, 0x061C, 0x05DC, 0x059C, 0x055C, 0x051C, 0x04DC, 0x049C, 0x045C, 0x041C, 0x03DC, 0x039C,
                0x036C, 0x034C, 0x032C, 0x030C, 0x02EC, 0x02CC, 0x02AC, 0x028C, 0x026C, 0x024C, 0x022C, 0x020C, 0x01EC, 0x01CC, 0x01AC, 0x018C,
                0x0174, 0x0164, 0x0154, 0x0144, 0x0134, 0x0124, 0x0114, 0x0104, 0x00F4, 0x00E4, 0x00D4, 0x00C4, 0x00B4, 0x00A4, 0x0094, 0x0084,
                0x0078, 0x0070, 0x0068, 0x0060, 0x0058, 0x0050, 0x0048, 0x0040, 0x0038, 0x0030, 0x0028, 0x0020, 0x0018, 0x0010, 0x0008, 0x0000
            };

            if (fileSize < sampleCount*1) goto free_and_return_null;
            for (mo_uint64 i = 0; i < sampleCount; ++i) {
                pSamples[i] = table[pFileData8[i]];
            }
            pFileData8 += sampleCount*1; fileSize -= (size_t)sampleCount*1;
        } break;

        // Unknown or unsupported format.
        default: goto free_and_return_null;
    }

    if (pChannels) *pChannels = (unsigned int)channels;
    if (pSampleRate) *pSampleRate = (unsigned int)sampleRate;
    if (pSampleCount) *pSampleCount = sampleCount;
    return pSamples;

free_and_return_null:
    MO_WAV_FREE(pSamples);
    return NULL;

    #undef MO_WAV_MALLOC
    #undef MO_WAV_FREE
    #undef MO_WAV_COPY
    #undef MO_WAV_SEEK
    #undef MO_WAV_READ_UINT8
    #undef MO_WAV_READ_UINT16
    #undef MO_WAV_READ_UINT32
    #undef MO_WAV_READ_UINT64
    #undef MO_WAV_READ_GUID
    #undef MO_WAV_GUID_EQUAL
}

#ifdef MO_HAS_STB_VORBIS
static mo_bool32 mo_is_vorbis_stream(size_t dataSize, const void* pData)
{
    // This is a simple check to see if the given data is a valid Vorbis stream.
    stb_vorbis* pDecoder = stb_vorbis_open_memory((const unsigned char*)pData, (int)dataSize, NULL, NULL);
    mo_bool32 isVorbis = pDecoder != NULL;

    stb_vorbis_close(pDecoder);
    return isVorbis;
}
#endif

#ifdef MO_HAS_DR_FLAC
static mo_bool32 mo_is_flac_stream(size_t dataSize, const void* pData)
{
    // This is a simple check to see if the given data is a valid Vorbis stream.
    drflac* pDecoder = drflac_open_memory(pData, dataSize);
    mo_bool32 isFlac = pDecoder != NULL;

    drflac_close(pDecoder);
    return isFlac;
}
#endif

mo_result mo_sound_source_load(mo_context* pContext, const char* filePath, mo_sound_source** ppSource)
{
    if (ppSource == NULL) return MO_INVALID_ARGS;
    mo_zero_object(ppSource);

    if (pContext == NULL || filePath == NULL) return MO_INVALID_ARGS;

    size_t fileSize;
    void* pFileData = mo_open_and_read_file(pContext, filePath, &fileSize);
    if (pFileData == NULL) {
        return MO_DOES_NOT_EXIST;
    }

    mo_result result = MO_INVALID_RESOURCE;
    mo_sound_source* pSource = NULL;

    // WAV / Raw.
    unsigned int channels;
    unsigned int sampleRate;
    uint64_t totalSampleCount;
    mo_int16* pSampleDataS16 = mo_sound_source_load__wav(pFileData, fileSize, &channels, &sampleRate, &totalSampleCount);
    if (pSampleDataS16 != NULL) {
        result = mo_sound_source_create(pContext, channels, sampleRate, totalSampleCount, pSampleDataS16, &pSource);
        mo_free(pSampleDataS16);
    }

#ifdef MO_HAS_STB_VORBIS
    if (pSource == NULL) {
        if (mo_is_vorbis_stream(fileSize, pFileData)) {
            result = mo_sound_source_create_vorbis(pContext, fileSize, pFileData, &pSource);
        }
    }
#endif
#ifdef MO_HAS_DR_FLAC
    if (pSource == NULL) {
        if (mo_is_flac_stream(fileSize, pFileData)) {
            result = mo_sound_source_create_flac(pContext, fileSize, pFileData, &pSource);
        }
    }
#endif

    mo_free(pFileData);

    if (pSource == NULL) {
        return MO_INVALID_RESOURCE;
    }

    if (totalSampleCount > SIZE_MAX) {
        return MO_INVALID_RESOURCE; // The file's too big.
    }

    *ppSource = pSource;
    return result;
}

void mo_sound_source_delete(mo_sound_source* pSource)
{
    if (pSource == NULL) return;
    mo_free(pSource);
}

mo_result mo_play_sound_source(mo_context* pContext, mo_sound_source* pSource, mo_uint32 group)
{
    if (pContext == NULL || pSource == NULL) return MO_INVALID_ARGS;

    mo_sound* pSound;
    mo_result result = mo_sound_create(pContext, pSource, group, &pSound);
    if (result != MO_SUCCESS) {
        return result;
    }

    pSound->flags |= MO_SOUND_FLAG_INLINED;
    mo_sound_play(pSound, MO_FALSE);

    return MO_SUCCESS;
}


void mo_sound_group_pause(mo_context* pContext, mo_uint32 group)
{
    if (pContext == NULL || group < MO_SOUND_GROUP_COUNT) return;
    pContext->soundGroups[group].flags |= MO_SOUND_GROUP_FLAG_PAUSED;
}

void mo_sound_group_resume(mo_context* pContext, mo_uint32 group)
{
    if (pContext == NULL || group < MO_SOUND_GROUP_COUNT) return;
    pContext->soundGroups[group].flags &= ~MO_SOUND_GROUP_FLAG_PAUSED;
}

mo_bool32 mo_sound_group_is_paused(mo_context* pContext, mo_uint32 group)
{
    if (pContext == NULL || group < MO_SOUND_GROUP_COUNT) return MO_FALSE;
    return (pContext->soundGroups[group].flags & MO_SOUND_GROUP_FLAG_PAUSED) != 0;
}

void mo_sound_group_set_volume(mo_context* pContext, mo_uint32 group, float linearVolume)
{
    if (pContext == NULL || group < MO_SOUND_GROUP_COUNT) return;
    if (linearVolume < 0) linearVolume = 0;
    pContext->soundGroups[group].linearVolume = linearVolume;
}


mo_result mo_sound_create(mo_context* pContext, mo_sound_source* pSource, mo_uint32 group, mo_sound** ppSound)
{
    if (ppSound == NULL) return MO_INVALID_ARGS;
    mo_zero_object(ppSound);

    if (pContext == NULL || pSource == NULL || group >= MO_SOUND_GROUP_COUNT) return MO_INVALID_ARGS;

    mo_sound* pSound = (mo_sound*)mo_calloc(sizeof(*pSound));
    if (pSound == NULL) {
        return MO_OUT_OF_MEMORY;
    }

    pSound->pContext = pContext;
    pSound->pSource = pSource;
    pSound->group = group;
    pSound->linearVolume = 1;
    pSound->pan = 0;

    // Depending on the sound source we may need some per-sound decoding information.
    if (pSource->type == mo_sound_source_type_raw)
    {
        pSound->raw.currentSample = 0;
    }
#ifdef MO_HAS_STB_VORBIS
    else if (pSource->type == mo_sound_source_type_vorbis)
    {
        pSound->vorbis.currentSample = 0;
        pSound->vorbis.pDecoder = stb_vorbis_open_memory((const unsigned char*)pSource->vorbis.pData, (int)pSource->vorbis.dataSize, NULL, NULL);
        if (pSound->vorbis.pDecoder == NULL) {
            mo_free(pSound);
            return MO_INVALID_RESOURCE;
        }
    }
#endif
#ifdef MO_HAS_DR_FLAC
    else if (pSource->type == mo_sound_source_type_flac)
    {
        pSound->flac.currentSample = 0;
        pSound->flac.pDecoder = drflac_open_memory(pSource->flac.pData, pSource->flac.dataSize);
        if (pSound->flac.pDecoder == NULL) {
            mo_free(pSound);
            return MO_INVALID_RESOURCE;
        }
    }
#endif

    // Add the sound to the array.
    if (pContext->soundBufferSize == pContext->soundCount) {
        mo_uint32 newSoundBufferSize = (pContext->soundBufferSize == 0) ? 8 : pContext->soundBufferSize*2;
        mo_sound** ppNewSounds = (mo_sound**)mo_realloc(pContext->ppSounds, newSoundBufferSize * sizeof(*ppNewSounds));
        if (ppNewSounds == NULL) {
            mo_free(pSound);
            return MO_OUT_OF_MEMORY;
        }

        pContext->ppSounds = ppNewSounds;
        pContext->soundBufferSize = newSoundBufferSize;
    }

    mo_assert(pContext->soundBufferSize > pContext->soundCount);
    pContext->ppSounds[pContext->soundCount] = pSound;
    pContext->soundCount += 1;


    *ppSound = pSound;
    return MO_SUCCESS;
}

void mo_sound_delete(mo_sound* pSound)
{
    if (pSound == NULL) return;

    mo_context* pContext = pSound->pContext;
    mo_assert(pContext != NULL);

    for (mo_uint32 iSound = 0; iSound < pContext->soundCount; ++iSound) {
        if (pContext->ppSounds[iSound] == pSound) {
            for (; iSound < pContext->soundCount-1; ++iSound) {
                pContext->ppSounds[iSound] = pContext->ppSounds[iSound+1];
            }

            pContext->soundCount -= 1;
            break;
        }
    }

    mo_free(pSound);
}

void mo_sound_mark_for_deletion(mo_sound* pSound)
{
    if (pSound == NULL || pSound->isMarkedForDeletion) return;

    mo_context* pContext = pSound->pContext;
    mo_assert(pContext != NULL);

    pSound->isMarkedForDeletion = MO_TRUE;
    mo_sound_stop(pSound);

    pContext->isSoundMarkedForDeletion = MO_TRUE;
}

void mo_sound_set_volume(mo_sound* pSound, float linearVolume)
{
    if (pSound == NULL) return;
    if (linearVolume < 0) linearVolume = 0;
    pSound->linearVolume = linearVolume;
}

void mo_sound_play(mo_sound* pSound, mo_bool32 loop)
{
    if (pSound == NULL) return;

    if (loop) {
        pSound->flags |= MO_SOUND_FLAG_LOOPING;
    } else {
        pSound->flags &= ~MO_SOUND_FLAG_LOOPING;
    }

    pSound->flags |= MO_SOUND_FLAG_PLAYING;
}

void mo_sound_stop(mo_sound* pSound)
{
    if (pSound == NULL) return;
    pSound->flags &= ~MO_SOUND_FLAG_PLAYING;
}

mo_bool32 mo_sound_is_playing(mo_sound* pSound)
{
    if (pSound == NULL) return MO_FALSE;
    return (pSound->flags & MO_SOUND_FLAG_PLAYING) != 0;
}

mo_bool32 mo_sound_is_looping(mo_sound* pSound)
{
    if (pSound == NULL) return MO_FALSE;
    return (pSound->flags & MO_SOUND_FLAG_LOOPING) != 0;
}


//// Input ////

static int mo_get_button_index(mo_button button)
{
    for (int i = 0; i < MO_BUTTON_COUNT; ++i) {
        if (button & (1 << i)) {
            return i;
        }
    }

    return -1;
}

void mo_bind_key_to_button(mo_context* pContext, mo_key key, mo_button button)
{
    if (pContext == NULL) return;

    int index = mo_get_button_index(button);
    if (index == -1 || index >= MO_BUTTON_COUNT) {
        return;
    }

    pContext->keymap[index] = key;
}

mo_button mo_get_key_binding(mo_context* pContext, mo_key key)
{
    if (pContext == NULL) return 0;

    for (int i = 0; i < MO_BUTTON_COUNT; ++i) {
        if (pContext->keymap[i] == key) {
            return (mo_button)(1 << i);
        }
    }

    return 0;
}

mo_bool32 mo_is_button_down(mo_context* pContext, unsigned int button)
{
    if (pContext == NULL) return MO_FALSE;
    return (pContext->buttonState & button) != 0;
}

mo_bool32 mo_was_button_pressed(mo_context* pContext, unsigned int button)
{
    if (pContext == NULL) return MO_FALSE;
    return (pContext->buttonPressState & button) != 0;
}

mo_bool32 mo_was_button_released(mo_context* pContext, unsigned int button)
{
    if (pContext == NULL) return MO_FALSE;
    return (pContext->buttonReleaseState & button) != 0;
}


//// Miscellaneous ////

mal_uint32 mo_get_line_height(mo_context* pContext)
{
    (void)pContext;
    return 9;
}

mal_uint32 mo_get_character_width(mo_context* pContext)
{
    (void)pContext;
    return 9;
}

mal_uint32 mo_get_text_width(mo_context* pContext, const char* text)
{
    return (mo_uint32)strlen(text) * mo_get_character_width(pContext);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// mini_al Implementation
//
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define MAL_IMPLEMENTATION
#ifndef MO_USE_EXTERNAL_MINI_AL
#endif  //MO_USE_EXTERNAL_MINI_AL

#endif  //MINTARO_IMPLEMENTATION


// REVISION HISTORY
// ================
//
// v0.2 - TBD
//   - Added support for loading PCX images via dr_pcx.
//   - Fixed C++ build when building with stb_image enabled.
//
// v0.1 - 2016-10-27
//   - Initial versioned release.


/*
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
*/
